"""
Framsticks as a Python module.

This text is from frams.pyi file.
Put this file next to `frams.py` file.
"""

import ctypes
from typing import Any, overload, type_check_only
from typing import Any as Object
from warnings import deprecated

c_api: ctypes.CDLL

home_dir: str
res_dir: str


def init(*args) -> None: ...


class ExtValue[T]:  # Note: Python 3.12 syntax
    """All Framsticks objects and values are instances of this class.
    Read the documentation of the 'frams' module for more information.
    """

    def _type(self) -> int | Any: ...
    def _class(self) -> Any: ...
    # def _value(self) -> int | float | str | ExtValue: ...
    def _value(self) -> T: ...


class CheckpointEvent(ExtValue):
    "Used in onSlaveCheckpoint() which is called when a Slave Simulator checkpoint is reached."

    index: ExtValue[int]
    "Slave index"
    slave: ExtValue  # Simulator
    ticks: ExtValue[int]
    "Simulator ticks"
    data: ExtValue  # untyped
    "Checkpoint data"


class Collision(ExtValue):
    "Used in collision handlers (On___Collision). Contains the detailed information about the colliding parts (Part1,Part2 and their associated MechParts and Creatures). See the onFoodCollision() function in standard.expdef"

    Part1: ExtValue  # Object
    Part2: ExtValue  # Object
    MechPart1: ExtValue  # Object
    MechPart2: ExtValue  # Object
    Creature1: ExtValue  # Object
    Creature2: ExtValue  # Object


class CrCollision(ExtValue):
    "Used in creature collision handlers (On___CrCollision)."

    Creature1: ExtValue  # Object
    Creature2: ExtValue  # Object


class Creature(ExtValue):
    """
    The object inside the simulated world, including its physical structure, neural network and performance data. Food pieces, obstacles and other movable objects can be implemented as Creatures even though the are not "alive".
    Before version 4.0rc4 the static Creature object was used in event handlers and in functions operating on the "selected" creature. This is now deprecated as all operations can be performed using the more convenient direct access (see GenePools). For event handlers, the creature object will be passed as argument, like this:
    function onDied(cr) {Simulator.print("Creature "+cr.name+" has died");}
    See also: Population.
    """

    name: ExtValue[str]
    genotype: ExtValue[str]
    info: ExtValue[str]
    "Additional info or comments"
    group: ExtValue  # untyped
    """
    creature's Population
    
    Deprecated. Use population instead.
    """
    population: ExtValue  # Population
    "creature's population"
    index: ExtValue[int]
    """
    current index in population
    
    Note that the index changes depending on the current creature position in the population. Use Creature.uid if you need a permanent identifier that persists through the entire object lifetime.
    """
    num: ExtValue[int]
    """
    Ordinal number
    
    Acts as a unique identifier, but less strict than "uid". Unlike "uid", "num" can be changed and therefore can be saved and restored, providing persistence and continuity beyond a single application run. "num" is only guaranteed to be unique if it is autogenerated and not changed by the user, otherwise it is user's responsibility to manage the proper values of "num". Autogenerated "num" is always equal to the largest previously used "num" + 1. The largest previously used value is stored in Simulator.last_creature_num and can be changed as well (and is automatically saved and restored as a part of the Simulator state). Limitation: being a 32-bit integer, "num" overflows at about 2 billion counts.
    See also: uid
    """
    gnum: ExtValue[int]
    "Generation"
    buildproblems: ExtValue[int]
    "Build problems"
    energ0: ExtValue[float]
    "Starting energy"
    energy0: ExtValue[float]
    "Starting energy"
    idleen: ExtValue[float]
    """
    Idle energy consumption
    
    The amount of energy subtracted from the energy of this creature in each simulation step, as in: cr.energy-=cr.idleen;
    """
    energy: ExtValue[float]
    perf: ExtValue[int]
    """
    Performance calculation
    
    Replaced by perf_measuring
    """
    perf_measuring: ExtValue[int]
    """
    Performance calculation
    
    The initial value of this property is taken from Population.initial_perf_measuring
    """
    nnenabled: ExtValue[int]
    """
    NN enabled
    
    Replaced by nn_active
    """
    nn_active: ExtValue[int]
    """
    NN active
    
    The initial value of this property is taken from Population.nn_active
    """
    bodysim: ExtValue[int]
    """
    Body simulation
    
    Replaced by physics_active
    """
    physics_active: ExtValue[int]
    """
    Body simulation
    
    (Physical) body simulation can be disabled for individual objects which makes them immovable. Disabled objects can still participate in collisions depending on their collisions masks. The initial value of this property is taken from Population.initial_physics_active.
    
    Bugs: the standard collision handler does not work for disabled objects when ODE simulation is used. It means that these objects won't physically interact with other objects. The custom (scripting) handlers work as expected.
    """
    selfcol: ExtValue[int]
    """
    Self-collisions
    
    Replaced by self_collisions
    """
    self_collisions: ExtValue[int]
    """
    Self-collisions
    
    Enable/disable detection of self-collisions (within a creature body). They can only occur when using the ODE simulation engine. If enabled, the creature will have its sticks collide during lifespan.  The initial value of this property is taken from Population.initial_self_collisions.
    """

    @deprecated
    @staticmethod
    def selfcolstate() -> ExtValue[int]:
        """
        Self-collisions

        Replaced by selfCollisionsCount()
        """
        ...

    @staticmethod
    def selfCollisionsCount() -> ExtValue[int]:
        """
        Current self-collisions state

        Returns the number of self-collisions detected in the creature.
        """
        ...

    lifespan: ExtValue[int]
    "While the creature's performance measurement is enabled, the creature's lifespan is incremented in \"performance sampling period\" intervals."
    steps_after_birth: ExtValue[int]
    """
    Simulation steps after birth
    
    "Birth" is the moment when the simulation of a creature starts.
    """
    steps_in_lifespan: ExtValue[int]
    """
    Simulation steps in lifespan
    
    "Lifespan" is the period during simulation of a creature when its performance measurement is enabled.
    """
    distance: ExtValue[float]
    "See http://www.framsticks.com/a/al_params.html#exper-perfcalc"
    c_velocity: ExtValue[float]
    """
    Recent period velocity
    
    See http://www.framsticks.com/a/al_params.html#exper-perfcalc
    """
    c_vertvelocity: ExtValue[float]
    """
    Recent period vertical velocity
    
    See http://www.framsticks.com/a/al_params.html#exper-perfcalc
    """
    c_vertpos: ExtValue[float]
    """
    Recent period vertical position
    
    See http://www.framsticks.com/a/al_params.html#exper-perfcalc
    """
    velocity: ExtValue[float]
    """
    Average velocity
    
    See http://www.framsticks.com/a/al_params.html#exper-perfcalc
    """
    vertpos: ExtValue[float]
    """
    Average vertical position
    
    See http://www.framsticks.com/a/al_params.html#exper-perfcalc
    """
    vertvel: ExtValue[float]
    """
    Average vertical velocity
    
    See http://www.framsticks.com/a/al_params.html#exper-perfcalc
    """
    pos_x: ExtValue[float]
    """
    Position x
    
    (pos_x,pos_y,pos_z) is the point of minimal coordinates ("bottom left corner") of the creature, including imaginary Part sizes (Part.s, usually 1.0). See also: Creature.moveAbs
    """
    pos_y: ExtValue[float]
    """
    Position y
    
    See Creature.pos_x
    """
    pos_z: ExtValue[float]
    """
    Position z
    
    See Creature.pos_x
    """
    size_x: ExtValue[float]
    """
    Bounding box x size
    
    (size_x,size_y,size_z) are dimensions of the axis-aligned bounding box of the creature, including the imaginary part sizes (Part.s, usually 1.0). A creature consisting of a single default Part has the size of (2.0,2.0,2.0) - twice the Part.s value (like a sphere diameter is twice its radius).
    See also: Creature.moveAbs
    """
    size_y: ExtValue[float]
    """
    Bounding box y size
    
    See Creature.size_x
    """
    size_z: ExtValue[float]
    """
    Bounding box z size
    
    See Creature.size_x
    """
    center_x: ExtValue[float]
    """
    center.x
    
    Center of gravity
    """
    center_y: ExtValue[float]
    """
    center.y
    
    Center of gravity
    """
    center_z: ExtValue[float]
    """
    center.z
    
    Center of gravity
    """
    bboxLow: ExtValue  # XYZ
    "Bounding box 'low' corner"
    bboxHigh: ExtValue  # XYZ
    "Bounding box 'high' corner"
    bboxCenter: ExtValue  # XYZ
    "Bounding box center"
    bboxSize: ExtValue  # XYZ
    "Bounding box size"
    bboxGroundOffset: ExtValue[float]
    """
    Bounding box ground offset
    
    Due to multiple modes of simulation and Part shapes, you need to add this value to the intended creature bottom elevation to get the 'z' coordinate of the bboxLow that places the creature exactly on the specific height level.
    Example:
    creature.locationSetBboxLow(10,10,0+creature.bboxGroundOffset); //bottom of the crearture will be at level 0 on a flat ground
    """
    centerOfGravity: ExtValue  # XYZ
    """
    Center of gravity
    
    See http://www.framsticks.com/a/al_params.html#exper-perfcalc
    """
    numparts: ExtValue[int]
    "Number of body Parts"
    numjoints: ExtValue[int]
    "Number of body Joints"
    numneurons: ExtValue[int]
    "Number of neurons"
    numconnections: ExtValue[int]
    "Number of neural connections"
    data: ExtValue  # Dictionary
    "Custom fields dictionary"
    user1: ExtValue  # untyped
    "User field 1"
    user2: ExtValue  # untyped
    "User field 2"
    user3: ExtValue  # untyped
    "User field 3"

    @deprecated
    @staticmethod
    def move(dx: float, dy: float, dz: float) -> ExtValue[None]:
        """
        Move by a vector

        Replaced by locationMoveBy().
        """
        ...

    @staticmethod
    def locationMoveBy(dx: float, dy: float, dz: float) -> ExtValue[None]:
        """
        Move by a vector

        Shift the creature by a given vector (in world coordinates).
        """
        ...

    @deprecated
    @staticmethod
    def moveAbs(x: float, y: float, z: float) -> ExtValue[None]:
        """
        Move to absolute location

        Replaced by locationSetBboxLow().
        """
        ...

    @staticmethod
    def locationSetBboxLow(x: float, y: float, z: float) -> ExtValue[None]:
        """
        Move bounding box corner to absolute location

        Moves the creature as determined by the "low" corner (the one with the lower coordinate values) of the bounding box of a creature.
        """
        ...

    @staticmethod
    def locationSetBboxCenter(x: float, y: float, z: float) -> ExtValue[None]:
        """
        Move bounding box center to absolute location

        Moves the creature as determined by the center of the bounding box of a creature.
        """
        ...

    @deprecated
    @staticmethod
    def moveLocal(dx: float, dy: float, dz: float) -> ExtValue[None]:
        """
        Move by a vector in local coordinates

        Replaced by locationMoveLocalBy
        """
        ...

    @staticmethod
    def locationMoveLocalBy(dx: float, dy: float, dz: float) -> ExtValue[None]:
        """
        Move by a vector in local coordinates

        Local coordinates are measured with respect to the position and orientation of the first Part.
        """
        ...

    @staticmethod
    def localToWorld(x: float, y: float, z: float) -> ExtValue:  # returns XYZ
        """
        Return world coordinates

        Local coordinates are measured with respect to the position and orientation of the first Part.
        """
        ...

    @staticmethod
    def worldToLocal(x: float, y: float, z: float) -> ExtValue:  # returns XYZ
        """
        Return local coordinates

        Local coordinates are measured with respect to the position and orientation of the first Part.
        """
        ...

    orient: ExtValue  # Orient
    """
    Orientation
    
    By convention, the orientation of the creature is equal to the orientation of its first Part.
    """

    @staticmethod
    def rotate(x: float, y: float, z: float) -> ExtValue[None]:
        "Rotate the creature around X, Y and Z axes. Should only be used immediately after creating a new creature (before the first simulation step is performed for this creature), otherwise further simulation can be disturbed."
        ...

    @staticmethod
    def rotateLocal(x: float, y: float, z: float) -> ExtValue[None]:
        """
        Rotate in local coordinates

        Rotate the creature around (local) X, Y and Z axes. Should only be used immediately after creating a new creature (before the first simulation step is performed for this creature), otherwise further simulation can be disturbed.
        """
        ...

    drive: ExtValue  # XYZ
    """
    Enforce constant speed
    
    Measured in global coordinates.
    """
    driveLocal: ExtValue  # XYZ
    """
    Enforce local constant speed
    
    Measured in local coordinates, that is, with respect to the current orientation of the creature.
    See also: Creature.orient
    """
    localDrive: ExtValue  # XYZ
    """
    Enforce constant speed
    
    This field is now called driveLocal.
    """

    @staticmethod
    def getPart(index: int) -> ExtValue:  # returns Part
        "Get Part (static Model information)"
        ...

    @staticmethod
    def getJoint(index: int) -> ExtValue:  # returns Joint
        "Get Joint (static Model information)"
        ...

    @staticmethod
    def getNeuroDef(index: int) -> ExtValue:  # returns NeuroDef
        "Get NeuroDef"
        ...

    @staticmethod
    def getMechPart(index: int) -> ExtValue:  # returns MechPart
        "Get MechPart (current properties)"
        ...

    @staticmethod
    def getMechJoint(index: int) -> ExtValue:  # returns MechJoint
        "Get MechJoint (current properties)"
        ...

    @staticmethod
    def getNeuro(index: int) -> ExtValue:  # returns Neuro
        "Get Neuro"
        ...

    outdated_neuro_classes: ExtValue  # untyped
    """
    Outdated neuro classes
    
    Names of the neuron classes that have been modified after this creature was built
    """
    selfmask: ExtValue[int]
    """
    Collision mask (self)
    
    Creature's selfmask is set according to the Creature's Population.selfmask. See Population.selfmask for detailed information about collision handling.
    """
    othermask: ExtValue[int]
    """
    Collision mask (other)
    
    Creature's othermask is set according to the Creature's Population.othermask. See Population.selfmask for detailed information about collision handling.
    """
    geno: ExtValue  # Geno
    """
    Genotype
    
    Source genotype for this creature
    """
    model: ExtValue  # Model
    """
    Source Model
    
    Source Model for this creature
    """
    liveModel: ExtValue  # Model
    """
    Current Model
    
    A Model object that is a copy of the current (temporary) geometry of this creature
    """
    uid: ExtValue[str]
    """
    #
    
    Unique identifier that is generated on object creation. "uid" is only unique during a single application run. Subsequent runs generate the same sequence of uid values.
    See also: num
    """
    signals: ExtValue  # CreatureSignals
    "Signal sources"

    @staticmethod
    def boundingBoxCollisions(mask: int) -> ExtValue[int]:
        """
        Check bounding box collisions

        Checks approximate collisions for the selected creature.
        Returns the collision mask calculated as ( mask & colliding_creatures.othermask ). Usually called with mask=0, which has the special meaning of using the current creature.selmask instead of 0, so that it detects the same type of collisions as the current experiment configuration.
        Passing non-zero mask value uses it instead of creature.selfmask, allowing you to include or exclude other colliding populations, as if creature.selfmask were modified temporarily.
        """
        ...

    @staticmethod
    def checkCollisions(mask: int, accuracy: int) -> ExtValue:  # returns untyped
        """
        Check collisions

        Returns zero if the creature does not collide with other creatures.
        Arguments:
        - mask: if not zero, temporarily replaces creature.selfmask. For details see boundingBoxCollisions()
        - accuracy:
         0 = testing creature bounding boxes
         1 = testing creature elements
        """
        ...

    @staticmethod
    def transferEnergyTo(recipient: "Creature", requested_amount_of_energy: float) -> ExtValue[float]:
        """
        Transfer energy

        Transfers at most the requested_amount_of_energy from this creature to the recipient. Returns the amount of energy actually transferred.
        The function will only transfer positive amounts and will not transfer more energy than this creature has, so the function is equivalent to:
        if (this.energy>0 && requested_amount_of_energy>0)
        {
          var amount = Math.min(requested_amount_of_energy, this.energy);
          recipient.energy += amount;
          this.energy -= amount;
        }

        Calling this function from inside the collision handler to transfer energy between colliding parts automatically adds the relevant MechPart references, as if transferEnergyToPart was called, i.e.
                Collision.Creature1.transferEnergyTo(Collision.Creature2, e);
        is equivalent to:
                Collision.Creature1.transferEnergyToPart(Collision.Part1, Collision.Creature2, Collision.Part2, e);
        When this behavior is not intended, explicit nulls in transferEnergyToPart() can be used to avoid associating the energy transfer with the currently colliding parts, like this:
                Collision.Creature1.transferEnergyToPart(null, Collision.Creature2, null, e);
        """
        ...

    @staticmethod
    def transferEnergyToPart(
        source_part: "MechPart", recipient_creature: "Creature", recipient_part: "MechPart", requested_amount_of_energy: float
    ) -> ExtValue[float]:
        """
        Transfer energy

        Transfer energy between specific parts of two creatures. Part arguments are only used for visualization and can be null, which would mean "the entire creature".
        See also: transferEnergyTo()
        """
        ...


class CreatureSettings(ExtValue):
    "Creature building parameters"

    minjoint: ExtValue[float]
    "Minimal joint length"
    maxjoint: ExtValue[float]
    "Maximal joint length"
    randinit: ExtValue[float]
    """
    Random initialization
    
    Allowed range for initializing all neuron states with uniform distribution random numbers and zero mean. Set to 0 for deterministic initialization.
    """
    nnoise: ExtValue[float]
    """
    Noise
    
    Gaussian neural noise: a random value is added to each neural output in each simulation step. Set standard deviation here to add random noise, or 0 for deterministic simulation.
    """
    touchrange: ExtValue[float]
    "T receptor range"
    bnoise_struct: ExtValue[float]
    """
    Body disturbance
    
    When >0, body constructs of creatures (position of Parts) will be randomly disturbed when they are created.
    """
    bnoise_vel: ExtValue[float]
    """
    Initial movement
    
    Random velocities will be applied to all body Parts (in MechaStick) or rigid segments (in ODE) of newly created creatures.
    """


class CreatureSignals(ExtValue):
    "Signal sources associated with a creature. See also: Signal, WorldSignals, NeuroSignals."

    @staticmethod
    def add(channel: str) -> ExtValue:  # returns Signal
        "Create a new signal"
        ...

    @staticmethod
    def addProperty(channel: str, property: Any) -> ExtValue:  # returns Signal
        """
        Create property-based signal

        Create a signal that automatically reflects one of the creature's properties (i.e. its power is equal to the property value).
        Example:
        Creature.signals.addProperty("energy","energy"); //then, Neuro.signals.receive("energy") in a custom neuron would work similarly to a built-in smell sensor.
        """
        ...

    @staticmethod
    def receive(channel: str) -> ExtValue[float]:
        """
        Receive signal in channel

        Receive the aggregated signal power in a given channel.
        """
        ...

    @staticmethod
    def receiveSet(channel: str, max_distance: float) -> ExtValue:  # returns Vector
        """
        Receive signals in range

        Get all signals in the specified range. Returns a read-only vector object containing Signal objects - individual signals can be accessed as result[0], .., result[result.size-1].
        """
        ...

    @staticmethod
    def receiveFilter(channel: str, max_distance: float, flavor: float, flavorfilter: float) -> ExtValue[float]:
        """
        Receive filtered signal

        Receive the aggregated signal power in a given channel.

        Additional filtering options:
        - Max distance only receives the neighbor signals (based on their physical location)
        - Flavor filtering: only signals having the flavor similar to the specified value will be received. The flavorfilter value is the difference of flavor that reduces the received signal to 0. The "flavor attenuation" is linear, i.e., signals differing by (filter/2) in flavor will be reduced to 50%.
        """
        ...

    @staticmethod
    def receiveSingle(channel: str, max_distance: float) -> ExtValue:  # returns Signal
        """
        Receive strongest

        Find the signal source that has the highest signal power (taking into account distance).
        """
        ...

    @staticmethod
    def get(index: int) -> ExtValue:  # returns Signal
        "Access individual signals (index = 0 .. size-1)"
        ...

    size: ExtValue[int]
    "Number of signals in this set"

    @staticmethod
    def clear() -> ExtValue[None]:
        "Delete all signals"
        ...


class CreatureSnapshot(ExtValue):
    """
    A data object consisting of the same fields as the serialized Creature. Typically used for reading a Creature back from a file; Population.add(snapshot_object) recreates the Creature object from the snapshot. When the creature is added to a population and it happens to collide with the terrain, the creature will be automatically moved upwards just enough to avoid the collision.
    Serialized Creature preserves most of its data fields (including the 'data' dictionary) but only keeps aggregated information about its physical state, which is body orientation and location of the bounding box center. Individual physical body parts' locations, states and neuron states are lost.
    Restoring the state of a formerly living, serialized creature using its CreatureSnapshot is not perfect. Apart from losing information about individual body and brain parts and their states, the usual flow of calculating performance may be disturbed, which is related to the 'performance sampling period' being interrupted as well as the specifics of the 'freezing period' mechanism. In consequence, the intended behavior of 'lifespan', 'steps_in_lifespan', and performance fields may be broken. For example, when period=100, after every 100 'steps_in_lifespan', the 'lifespan' increases by 100 and the new performance data is calculated. When the period is interrupted by saving/restoring, 'steps_in_lifespan' continues to increase from the saved value, but performance counters will be waiting another full 100 steps before the next update, losing the information from the unfinished period. The resulting 'lifespan' will be lower than it would have been without interruptions, and will be inconsistent with 'steps_in_lifespan'. Because of these issues, it is strongly advised to thoroughly inspect and test the behavior of the restored Creatures in various moments in their lifepspan, and use CreatureSnapshot only when necessary.
    See also: scripts/standard_exploadsave.inc
    See also: Population.add()
    """

    @staticmethod
    def new() -> ExtValue:  # returns Creature
        "create new object"
        ...

    name: ExtValue[str]
    genotype: ExtValue[str]
    info: ExtValue[str]
    "Additional info or comments"
    num: ExtValue[int]
    """
    Ordinal number
    
    Acts as a unique identifier, but less strict than "uid". Unlike "uid", "num" can be changed and therefore can be saved and restored, providing persistence and continuity beyond a single application run. "num" is only guaranteed to be unique if it is autogenerated and not changed by the user, otherwise it is user's responsibility to manage the proper values of "num". Autogenerated "num" is always equal to the largest previously used "num" + 1. The largest previously used value is stored in Simulator.last_creature_num and can be changed as well (and is automatically saved and restored as a part of the Simulator state). Limitation: being a 32-bit integer, "num" overflows at about 2 billion counts.
    See also: uid
    """
    gnum: ExtValue[int]
    "Generation"
    energy0: ExtValue[float]
    "Starting energy"
    idleen: ExtValue[float]
    """
    Idle energy consumption
    
    The amount of energy subtracted from the energy of this creature in each simulation step, as in: cr.energy-=cr.idleen;
    """
    energy: ExtValue[float]
    perf_measuring: ExtValue[int]
    """
    Performance calculation
    
    The initial value of this property is taken from Population.initial_perf_measuring
    """
    nn_active: ExtValue[int]
    """
    NN active
    
    The initial value of this property is taken from Population.nn_active
    """
    physics_active: ExtValue[int]
    """
    Body simulation
    
    (Physical) body simulation can be disabled for individual objects which makes them immovable. Disabled objects can still participate in collisions depending on their collisions masks. The initial value of this property is taken from Population.initial_physics_active.
    
    Bugs: the standard collision handler does not work for disabled objects when ODE simulation is used. It means that these objects won't physically interact with other objects. The custom (scripting) handlers work as expected.
    """
    self_collisions: ExtValue[int]
    """
    Self-collisions
    
    Enable/disable detection of self-collisions (within a creature body). They can only occur when using the ODE simulation engine. If enabled, the creature will have its sticks collide during lifespan.  The initial value of this property is taken from Population.initial_self_collisions.
    """
    lifespan: ExtValue[int]
    "While the creature's performance measurement is enabled, the creature's lifespan is incremented in \"performance sampling period\" intervals."
    steps_after_birth: ExtValue[int]
    """
    Simulation steps after birth
    
    "Birth" is the moment when the simulation of a creature starts.
    """
    steps_in_lifespan: ExtValue[int]
    """
    Simulation steps in lifespan
    
    "Lifespan" is the period during simulation of a creature when its performance measurement is enabled.
    """
    distance: ExtValue[float]
    "See http://www.framsticks.com/a/al_params.html#exper-perfcalc"
    c_velocity: ExtValue[float]
    """
    Recent period velocity
    
    See http://www.framsticks.com/a/al_params.html#exper-perfcalc
    """
    c_vertvelocity: ExtValue[float]
    """
    Recent period vertical velocity
    
    See http://www.framsticks.com/a/al_params.html#exper-perfcalc
    """
    c_vertpos: ExtValue[float]
    """
    Recent period vertical position
    
    See http://www.framsticks.com/a/al_params.html#exper-perfcalc
    """
    velocity: ExtValue[float]
    """
    Average velocity
    
    See http://www.framsticks.com/a/al_params.html#exper-perfcalc
    """
    vertpos: ExtValue[float]
    """
    Average vertical position
    
    See http://www.framsticks.com/a/al_params.html#exper-perfcalc
    """
    vertvel: ExtValue[float]
    """
    Average vertical velocity
    
    See http://www.framsticks.com/a/al_params.html#exper-perfcalc
    """
    center_x: ExtValue[float]
    """
    center.x
    
    Center of gravity
    """
    center_y: ExtValue[float]
    """
    center.y
    
    Center of gravity
    """
    center_z: ExtValue[float]
    """
    center.z
    
    Center of gravity
    """
    bboxCenter: ExtValue  # XYZ
    "Bounding box center"
    data: ExtValue  # Dictionary
    "Custom fields dictionary"
    user1: ExtValue  # untyped
    "User field 1"
    user2: ExtValue  # untyped
    "User field 2"
    user3: ExtValue  # untyped
    "User field 3"
    orient: ExtValue  # Orient
    """
    Orientation
    
    By convention, the orientation of the creature is equal to the orientation of its first Part.
    """
    selfmask: ExtValue[int]
    """
    Collision mask (self)
    
    Creature's selfmask is set according to the Creature's Population.selfmask. See Population.selfmask for detailed information about collision handling.
    """
    othermask: ExtValue[int]
    """
    Collision mask (other)
    
    Creature's othermask is set according to the Creature's Population.othermask. See Population.selfmask for detailed information about collision handling.
    """
    uid: ExtValue[str]
    """
    #
    
    Unique identifier that is generated on object creation. "uid" is only unique during a single application run. Subsequent runs generate the same sequence of uid values.
    See also: num
    """


class Dictionary(ExtValue):
    """
    Dictionary associates stored values with string keys ("key" is the first argument in get/set/remove functions). Integer key can be used to enumerate all elements (note that while iterating, the elements are returned in no particular order).
    Examples:
        var d;
        d=Dictionary.new();
        d.set("name","John");
        d.set("age",44);
    Another way of doing the same:
        d={};
        d["name"]="John";
        d["age"]=44;
    And the most concise way:
        d={ "name":"John", "age":44 };
    Iterating:
        for(var v in d) Simulator.print(v); //values
        for(var k in d.keys) Simulator.print(k+" is "+d[k]); //keys
        for(var i=0;i<d.size;i++) Simulator.print(d.getKey(i)+" is "+d.get(i)); //by index
    """

    @staticmethod
    def clear() -> ExtValue[None]:
        "Clear data"
        ...

    size: ExtValue[int]
    "Element count"

    @staticmethod
    def remove(key: Any) -> ExtValue[None]:
        "Removes the named or indexed element (depending on the argument type: string or int)."
        ...

    @staticmethod
    def get(key: Any) -> ExtValue:  # returns untyped
        """
        Get element

        Retrieves the named or indexed element (depending on the argument type: string or int). Accessing nonexistent keys is an error (use hasKey() if necessary).
        object.get(key) can be shortened to object[key].
        """
        ...

    @staticmethod
    def getKey(index: int) -> ExtValue[str]:
        """
        Get a key

        Returns the key of the indexed element (0 <= index < size).
        """
        ...

    @staticmethod
    def hasKey(key: str) -> ExtValue[int]:
        """
        Check if key exists

        Returns 1 (interpreted as true) if dictionary contains the supplied key, or 0 (false) otherwise.
        Example:
           if (obj.hasKey("a"))
              x = obj->a;
        """
        ...

    @staticmethod
    def set(key: Any, value: Any) -> ExtValue:  # returns untyped
        """
        Set element

        Set element value for the specified key or index (depending on the argument type: string or int).
        Returns the value previously associated with the given key (or index).
        object.set(key,value) can be shortened to object[key]=value. Literal string keys can use even shorter notation: object->key=value instead of object.set("key",value)
        Note the difference in the returned value:
          var old_value=object.set("key",new_value); //'old_value' gets the value previously associated with "key"
          var x=object["key"]=new_value; //'x' becomes 'new_value', consistently with the semantics of the assignment operator. The value previously associated with "key" is lost.
        """
        ...

    @staticmethod
    def find(value: Any) -> ExtValue:  # returns untyped
        "Returns the element key or null if not found."
        ...

    @staticmethod
    def new() -> ExtValue:  # returns Dictionary
        """
        Create a Dictionary

        Empty directory can be also created using the {} expression.
        """
        ...

    toString: ExtValue[str]
    "Textual form"

    @staticmethod
    def clone() -> ExtValue:  # returns Dictionary
        """
        Create a clone

        The resulting clone is a shallow copy (contains the same object references as the original). A deep copy can be obtained through serialization: String.deserialize(String.serialize(object));
        """
        ...

    @staticmethod
    def assign(_: Any) -> ExtValue[None]:
        """
        Assign from another object

        Replaces current dictionary with dictionary contents from another object.
        """
        ...

    iterator: ExtValue  # Object
    keys: ExtValue  # Object
    "Iterate over this object to get all keys: for(k in dict.keys) ..."


class EnergyParticles(ExtValue):
    enpa_lifespan_min: ExtValue[int]
    """
    Lifespan minimum
    
    Particle's lifespan is a random number taken from the specified range [min,max]
    """
    enpa_lifespan_max: ExtValue[int]
    """
    Lifespan maximum
    
    Particle's lifespan is a random number taken from the specified range [min,max]
    """
    enpa_amount_min: ExtValue[float]
    """
    Particle energy minimum
    
    A particle is emitted if the amount of energy transferred in a single step exceeds this threshold
    """
    enpa_amount_max: ExtValue[float]
    """
    Particle energy maximum
    
    A maximum amount of energy a single particle can represent. If energy transferred in a single simulation step exceeds this amount, more particles are created.
    """
    enpa_step_maxparticles: ExtValue[int]
    """
    Max particles per step
    
    Limit the number of particles created in a single step for each energy transfer
    """
    enpa_random_pos: ExtValue[float]
    """
    Randomize positions
    
    The amount of random shift used for individual particles (uniform distribution)
    """
    enpa_turn: ExtValue[float]
    """
    Turn towards target
    
    Ignore (0) or directly follow (1) the potentially moving target of a particle. Intermediate values create momentum effect as if the target was gradually adjusted.
    """
    enpa_speedup: ExtValue[float]
    """
    Particle speedup
    
    Increase particle speed by this factor in each simulation step. This can help reach moving targets (along with "Turn towards target").
    """
    enpa_fade: ExtValue[float]
    """
    Fade out orphans
    
    Gradually decrease particle size before it disappears when its energy transfer has ended while the particle was on its way. The remaining energy amount is multiplied by this factor in each step. 0 means: disappear immediately, 1 means: don't decrease the size at all. Note that these parameters only concern visualization and the actual energy was already transferred.
    """
    enpa_total_limit: ExtValue[int]
    """
    Total particle limit
    
    Limit the total number of existing energy particles (to save performance)
    """
    enpa_display_min: ExtValue[float]
    """
    Min particle size
    
    Visible particle size at minimum energy
    """
    enpa_display_max: ExtValue[float]
    """
    Max particle size
    
    Visible particle size at maximum energy
    """


class File(ExtValue):
    'Provides read/write access to the filesystem. Can be used in the experiment definition to save the experiment state (onExpSave) or any other information. Files are created in the "data/scripts_output" subdirectory, which is either near the Framsticks executable (if this subdirectory is writable) or in your user Documents directory.'

    name: ExtValue[str]
    path: ExtValue[str]
    "Full path"
    info: ExtValue[str]
    "Information"

    @staticmethod
    def writeNameObject(name: str, _: "Object") -> ExtValue[None]:
        "Write object with an alternative name"
        ...

    @staticmethod
    def writeObject(_: "Object") -> ExtValue[None]:
        "Write object"
        ...

    @staticmethod
    def writeObjectBegin(_: "Object") -> ExtValue[None]:
        "Write object header"
        ...

    @staticmethod
    def writeObjectField(_: "Object", field_index_or_name: Any) -> ExtValue[None]:
        "Write single field"
        ...

    @staticmethod
    def writeObjectFields(_: "Object") -> ExtValue[None]:
        "Write all fields"
        ...

    @staticmethod
    def writeObjectFieldForce(_: "Object", field_index_or_name: Any) -> ExtValue[None]:
        "Write single field"
        ...

    @staticmethod
    def writeObjectFieldsForce(_: "Object") -> ExtValue[None]:
        "Write all fields"
        ...

    @staticmethod
    def writeObjectEnd() -> ExtValue[None]:
        "Finish object"
        ...

    @staticmethod
    def writeString(anything: Any) -> ExtValue[None]:
        "Write anything"
        ...

    @staticmethod
    def writeComment(anything: str) -> ExtValue[None]:
        "Write comment string"
        ...

    @staticmethod
    def readLine() -> ExtValue[str]:
        """
        Read line

        Returns the next line read from file or null when there are no more lines.
        """
        ...

    @staticmethod
    def readObject(_: "Object") -> ExtValue[None]:
        "Read object"
        ...

    EOF: ExtValue[int]
    "End Of File?"

    @staticmethod
    def readUntilEOF() -> ExtValue[str]:
        "Read everything"
        ...

    @staticmethod
    def getContents(filename: str) -> ExtValue[str]:
        """
        Get file contents

        Shortcut to: var f=File.open(filename); c=f.readUntilEOF(); f.close(); return c;
        """
        ...

    @staticmethod
    def create(filename: str, description: str) -> ExtValue:  # returns File
        "Create a new buffered file"
        ...

    @staticmethod
    def createDirect(filename: str, description: str) -> ExtValue:  # returns File
        """
        Create a new unbuffered disk file

        Returns null if the file can't be created
        """
        ...

    @staticmethod
    def append(filename: str, description: str) -> ExtValue:  # returns File
        "Append buffered to the file"
        ...

    @staticmethod
    def appendDirect(filename: str, description: str) -> ExtValue:  # returns File
        """
        Append unbuffered to the disk file

        Returns null if the file can't be appended
        """
        ...

    @staticmethod
    def flush() -> ExtValue[None]:
        "Useful for unbuffered disk files only (openDirect, appendDirect)"
        ...

    @staticmethod
    def open(filename: str) -> ExtValue:  # returns File
        """
        Open existing file for reading

        Returns null if the file can't be read
        """
        ...

    stdin: ExtValue  # File
    "Standard input"
    stdout: ExtValue  # File
    "Standard output"

    @staticmethod
    def new() -> ExtValue:  # returns File
        "Create a new memory file"
        ...

    @staticmethod
    def newFromString(text: str) -> ExtValue:  # returns File
        "Create a new memory file with string contents"
        ...

    @staticmethod
    def close() -> ExtValue[str]:
        """
        Close the file

        Returns file contents if it has been buffered.
        """
        ...

    @staticmethod
    def exists() -> ExtValue[int]:
        """
        Test if a file exists

        Sample:
        File.exists("walking.gen") -> returns 0 or 1.
        """
        ...

    pathseparator: ExtValue[str]
    r"""
    Path separator: / or \
    """

    @staticmethod
    def callURL(url: str, post_data_or_null: Any, callback_or_null: "FunctionReference") -> ExtValue:  # returns Dictionary
        ...


class FunctionReference(ExtValue):
    """
    Function reference objects are created using the 'function' operator. The referenced function can be called using the 'call' operator:

        function abc(a,b)
        { return a+b; }

        var f=function abc;
        Simulator.print(typeof(f)); //"FunctionReference"
        Simulator.print(call(f)(123,321)); //444
    """


class GenePool(ExtValue):
    """
    GenePool objects are accessed by GenePools[index], or Genotype.genepool and created by GenePools.addGroup(). Usage of the static GenePool object is not recommended.
    You can iterate directly over Genotypes in the GenePool using for(...in...) loops:
        for(var genotype in GenePools[0]) Simulator.print(genotype.name);

    See also: GenePools
    """

    name: ExtValue[str]
    "Group name"
    index: ExtValue[int]
    "gene pool index"
    size: ExtValue[int]
    """
    Number of genotypes
    
    In standard.expdef, this is equivalent to the number of unique genotypes. Standard experiment definition uses the Genotype.instances field to indicate that some genotypes exist in multiple instances despite having only one item in the group. Other experiment definitions may create multiple copies of the same genotype.
    """
    genotype_instances: ExtValue[int]
    """
    Total number of genotype instances
    
    A sum of Genotype.instances values of all Genotypes in this gene pool.
    """
    totalpop: ExtValue[int]
    """
    Total number of genotype instances
    
    Please use 'genotype_instances' instead of this field.
    """
    fitness: ExtValue[str]
    """
    Fitness formula
    
    (For advanced users)
    """
    fitness_is_valid: ExtValue[int]
    """
    Fitness formula is valid
    
    (valid means can be compiled)
    """
    fitness_step_limit: ExtValue[int]
    """
    Fitness formula step limit
    
    (For advanced users)
    """
    fitness_time_limit: ExtValue[float]
    """
    Fitness formula time limit
    
    (For advanced users)
    """
    fitness_allowed_objs: ExtValue[str]
    """
    Fitness formula allowed objects
    
    For advanced users: a list of comma-separated names of object classes allowed in the fitness formula. Empty list means that there are no restrictions and all object classes are allowed.
    """
    fitfun: ExtValue[int]
    """
    Scale fitness?
    
    Enables fitness scaling.
    """
    fitm: ExtValue[float]
    """
    Shift coefficient
    
    Lower threshold: how many standard deviations below average?
    (avg - n * stddev) - used for fitness shifting
    """
    fitma: ExtValue[float]
    """
    Scaling coefficient
    
    The best genotype is as many times
    better than the average one.
    """

    @staticmethod
    def get(index: int) -> ExtValue:  # returns Genotype
        "Get a Genotype object"
        ...

    @deprecated
    @staticmethod
    def findGeno(_: "Geno") -> ExtValue[int]:
        """
        Find a Genotype index

        Finds the Genotype whose genes are identical to the supplied Geno object.
        Returns the Genotype index or -1 if not found.
        Deprecated. Use the more versatile GenePool.findGenotype() instead of this function.
        """
        ...

    @staticmethod
    def findGenotype(Genotype_object_or_Geno_object_or_string_genotype: Any) -> ExtValue:  # returns Genotype
        """
        Find a Genotype

        Finds the Genotype whose genes are identical to the supplied Genotype object, Geno object, or genotype string.
        Returns the Genotype object or null if not found.
        """
        ...

    @staticmethod
    def findUID(uid: str) -> ExtValue[int]:
        "Find a Genotype by UID"
        ...

    @deprecated
    @staticmethod
    def addGeno(_: "Geno") -> ExtValue:  # returns Genotype
        """
        Make a Genotype from Geno

        Creates a new Genotype from the supplied Geno object.
        Returns the created Genotype.
        Deprecated. Use the more versatile GenePool.add() instead of this function.
        """
        ...

    @deprecated
    @staticmethod
    def createFromGeno(_: "Geno") -> ExtValue:  # returns Genotype
        """
        same as addGeno (to comply with createFrom... convention)
        Deprecated. Use the more versatile GenePool.add() instead of this function.
        """
        ...

    @deprecated
    @staticmethod
    def createFromString(genotype: str) -> ExtValue:  # returns Genotype
        """
        Uses the supplied string argument.
        Deprecated. Use the more versatile GenePool.add() instead of this function.
        """
        ...

    @staticmethod
    def add(Geno_object_or_string_genotype: Any) -> ExtValue:  # returns Genotype
        """
        Add a genotype

        Creates a new Genotype from the supplied Geno or string.
        Returns the created Genotype.
        """
        ...

    @staticmethod
    def worst() -> ExtValue:  # returns Genotype
        "Returns the genotype object having the lowest fitness. Unrated genotypes (with instances=0) are ranked lower than those having at least one instance."
        ...

    @staticmethod
    def best() -> ExtValue:  # returns Genotype
        "Returns the genotype object having the highest fitness. Unrated genotypes (with instances=0) are ranked lower than those having at least one instance."
        ...

    @staticmethod
    def random() -> ExtValue:  # returns Genotype
        "Returns a random genotype object disregarding fitness value, but taking into account 'instances'. Unrated genotypes (with instances=0) are treated as if they had instances=1."
        ...

    @staticmethod
    def roulette() -> ExtValue:  # returns Genotype
        "Returns a randomly selected, fitness-proportional genotype object. Unrated genotypes (with instances=0) are treated as if they had instances=1 and average fitness."
        ...

    @staticmethod
    def revroulette() -> ExtValue:  # returns Genotype
        "Returns a randomly selected, reverse fitness-proportional genotype object. Unrated genotypes (with instances=0) are treated as if they had instances=1 and average fitness."
        ...

    @staticmethod
    def tournament(genotypes_in_tournament: int) -> ExtValue:  # returns Genotype
        "Returns a tournament winner genotype object. Unrated genotypes (with instances=0) are treated as if they had instances=1 and average fitness."
        ...

    @staticmethod
    def randomLikeGeno(minimum_similarity: float, target: "Geno") -> ExtValue:  # returns Genotype
        """
        Returns a random genotype index similar to the target genotype. Unrated genotypes (with instances=0) are treated as if they had instances=1 and average fitness. Read about details:
        http://www.framsticks.com/bib/Komosinski-et-al-2001
        http://www.framsticks.com/bib/Komosinski-and-Kubiak-2011
        http://www.framsticks.com/bib/Komosinski-2016
        """
        ...

    @staticmethod
    def rouletteLikeGeno(minimum_similarity: float, target: "Geno") -> ExtValue:  # returns Genotype
        """
        Returns a random genotype similar to the target genotype, fitness-proportional. Unrated genotypes (with instances=0) are treated as if they had instances=1 and average fitness. Read about details:
        http://www.framsticks.com/node/795
        http://www.framsticks.com/bib/Komosinski-and-Kubiak-2011
        http://www.framsticks.com/bib/Komosinski-2016
        """
        ...

    @staticmethod
    def delete(genotype_object_or_index: Any) -> ExtValue[None]:
        "Deletes a genotype."
        ...

    @staticmethod
    def deleteOne(genotype_object_or_index: Any) -> ExtValue[None]:
        "Deletes one individual, i.e. decreases its 'instances' and deletes the genotype if the 'instances' goes to 0."
        ...

    @staticmethod
    def clear() -> ExtValue[None]:
        "Delete all genotypes. GenePools[group].clear() is equivalent to GenePools.clearGroup(group)"
        ...

    @staticmethod
    def mergeInstances() -> ExtValue[None]:
        """
        Merge instances

        Merges instances of the same genotype.
        """
        ...

    @staticmethod
    def splitInstances() -> ExtValue[None]:
        """
        Split instances

        Splits genotype instances.
        """
        ...

    iterator: ExtValue  # Object

    @staticmethod
    def getStatsMin(field_name: str) -> ExtValue[float]:
        """
        get stats minimum

        Retrieves data from stats.* object. Can only be used for fields covered by stats.* (subset of Genotype fields).
        """
        ...

    @staticmethod
    def getStatsAvg(field_name: str) -> ExtValue[float]:
        """
        get stats average

        Retrieves data from stats.* object. Can only be used for fields covered by stats.* (subset of Genotype fields).
        """
        ...

    @staticmethod
    def getStatsMax(field_name: str) -> ExtValue[float]:
        """
        get stats maximum

        Retrieves data from stats.* object. Can only be used for fields covered by stats.* (subset of Genotype fields).
        """
        ...

    @staticmethod
    def refreshGUI() -> ExtValue[None]:
        """
        Refresh GUI

        Notify list content changed
        """
        ...


class GenePools(ExtValue):
    """
    Manages all genotypes in the experiment, organized in one or more groups.
    You can iterate directly over GenePool objects in the GenePools collection using for(...in...) loops:
        for(var pool in GenePools) Simulator.print(pool.name);

    Before version 4.0rc4, some operations could only be performed on the "selected" genotype (the one pointed to by group/genotype fields in GenePools). Currently, the more convenient and recommended way is to call Genotype's or GenePool's functions that operate directly on the passed objects.

    The old way:
        GenePools.newGenotype("X");
        GenePools.mutateSelected();
        Genotype.info="my favorite genotype";
        GenePools.copySelected(0);

    Doing the same the new way:
        var g=Genotype.newFromGeno(GenMan.mutate(Geno.newFromString("X")));
        g.info="my favorite genotype";
        g.moveTo(GenePools[0]);
    """

    group: ExtValue[int]
    """
    selected group
    
    Index of the currently selected group (GenePool).
    """
    size: ExtValue[int]
    "Number of groups"
    genotype: ExtValue[int]
    """
    selected genotype
    
    Index of the currently selected genotype or -1 if no genotype is selected.
    """

    @deprecated
    @staticmethod
    def newGenotype(genotype: str) -> ExtValue[None]:
        'Makes a new genotype from the supplied string and select the genotype. The resulting genotype is stored in the static Genotype object detached from the genotype group. After calling this function GenePools.genotype is -1 indicating that no genotype from the group is selected. (call "copySelected" if you want to add this gentype to the genotype group).'
        ...

    @deprecated
    @staticmethod
    def deleteSelected() -> ExtValue[None]:
        "Deletes selected genotype from the gene pool (uses the selected genotype object)."
        ...

    @deprecated
    @staticmethod
    def deleteOne(genotype_index: int) -> ExtValue[None]:
        "Deletes one individual from the gene pool = decreases 'instances' and deletes the genotype if the 'instances' goes to 0."
        ...

    @deprecated
    @staticmethod
    def copySelected(groupindex: int) -> ExtValue[None]:
        "Copies the selected genotype to another group."
        ...

    @deprecated
    @staticmethod
    def getFromCreature() -> ExtValue[None]:
        "Copies a genotype from the selected creature. The resulting genotype is stored in the static Genotype object detached from the genotype group."
        ...

    @deprecated
    @staticmethod
    def getFromCreatureObject(_: "Creature") -> ExtValue[None]:
        "Copies a genotype from the creature object passed in argument. The resulting genotype is stored in the static Genotype object detached from the genotype group."
        ...

    @deprecated
    @staticmethod
    def addPerformanceFromCreature() -> ExtValue[None]:
        "Updates the current Genotype's performance values merging them with the current Creture's performance. It assumes the Genotype.instances has a reasonable value and performs the proper weighting. Use your own function instead if these conditions are not met in your experiment."
        ...

    @deprecated
    @staticmethod
    def mutateSelected() -> ExtValue[None]:
        "Mutates the selected genotype. The resulting genotype is stored in the static Genotype object detached from the genotype group. After calling this function GenePools.genotype is -1 indicating that no genotype from the group is selected."
        ...

    @deprecated
    @staticmethod
    def crossoverSelected(other_index: int) -> ExtValue[None]:
        "Crossovers the selected genotype with another one (from the genotype group). The resulting genotype is stored in the static Genotype object detached from the genotype group. After calling this function GenePools.genotype is -1 indicating that no genotype from the group is selected."
        ...

    @deprecated
    @staticmethod
    def worst() -> ExtValue[int]:
        "Gets the worst (lowest fitness) genotype index. Unrated genotypes (instances=0) are ranked lower than those having at least one instance."
        ...

    @deprecated
    @staticmethod
    def random() -> ExtValue[int]:
        "Gets random genotype index."
        ...

    @deprecated
    @staticmethod
    def roulette() -> ExtValue[int]:
        "Gets a randomly selected, fitness-proportional genotype index. Unrated genotypes (with instances=0) are treated as if they had instances=1 and average fitness."
        ...

    @deprecated
    @staticmethod
    def revroulette() -> ExtValue[int]:
        "Gets a randomly selected, reverse fitness-proportional genotype index. Unrated genotypes (with instances=0) are treated as if they had instances=1 and average fitness."
        ...

    @deprecated
    @staticmethod
    def tournament(genotypes_in_tournament: int) -> ExtValue[int]:
        "Gets tournament winner genotype. Unrated genotypes (with instances=0) are treated as if they had instances=1 and average fitness."
        ...

    @deprecated
    @staticmethod
    def randomLikeThis(minimum_similarity: float) -> ExtValue[int]:
        "Gets a random genotype index similar to the selected one. Unrated genotypes (with instances=0) are treated as if they had instances=1 and average fitness."
        ...

    @deprecated
    @staticmethod
    def likeThisRoulette(minimum_similarity: float) -> ExtValue[int]:
        "Gets a random genotype similar to the selected one, fitness-proportional. Unrated genotypes (with instances=0) are treated as if they had instances=1 and average fitness."
        ...

    @deprecated
    @staticmethod
    def findGenotype() -> ExtValue[int]:
        """
        Finds a genotype identical to the currently selected genotype. It is only useful when the currently selected genotype is not on the list of genotypes (for example it is a result of a genetic operator)
        Deprecated. Use the more versatile GenePool.findGenotype() instead of this function.
        """
        ...

    @deprecated
    @staticmethod
    def findGenotypeForCreature() -> ExtValue[int]:
        """
        Finds a genotype identical to the genotype of the selected Creature.
        Deprecated. Use the more versatile GenePool.findGenotype() instead of this function.
        """
        ...

    @staticmethod
    def addGroup(name: str) -> ExtValue:  # returns GenePool
        "Adds a new gene pool."
        ...

    @staticmethod
    def deleteGroup(index: int) -> ExtValue[None]:
        "Removes a gene pool."
        ...

    @staticmethod
    def clear() -> ExtValue[None]:
        "Removes all gene pools except the first one."
        ...

    @deprecated
    @staticmethod
    def clearGroup(index: int) -> ExtValue[None]:
        'GenePools[group].clear() is more "object oriented" than GenePools.clearGroup(group)'
        ...

    @staticmethod
    def get(index: int) -> ExtValue:  # returns GenePool
        ...

    iterator: ExtValue  # Object


class GenMan(ExtValue):
    "Manages various genetic operations, using appropriate operators for the argument genotype format."

    gen_hist: ExtValue[int]
    """
    Remember history of genetic operations
    
    Required for phylogenetic analysis
    """
    gen_hilite: ExtValue[int]
    """
    Use syntax highlighting
    
    Use colors for genes?
    (slows down viewing/editing of huge genotypes)
    """
    gen_extmutinfo: ExtValue[int]
    """
    Extended mutation info
    
    If active, information about employed mutation method will be stored in the 'info' field of each mutated genotype.
    """

    @staticmethod
    def operReport() -> ExtValue[None]:
        """
        Operators report

        Show available genetic operators
        """
        ...

    @staticmethod
    def toHTML(_: str) -> ExtValue[str]:
        """
        HTMLize a genotype

        returns genotype expressed as colored HTML
        """
        ...

    @staticmethod
    def toHTMLshort(_: str) -> ExtValue[str]:
        """
        HTMLize a genotype, shorten if needed

        returns genotype (abbreviated if needed) in colored HTML format
        """
        ...

    @staticmethod
    def toLaTeX(_: str) -> ExtValue[str]:
        """
        LaTeXize a genotype

        returns genotype in colored LaTeX format
        """
        ...

    @staticmethod
    def validate(_: "Geno") -> ExtValue:  # returns Geno
        "returns validated (if possible) Geno object from supplied Geno"
        ...

    @staticmethod
    def mutate(_: "Geno") -> ExtValue:  # returns Geno
        "returns mutated Geno object from supplied Geno"
        ...

    @staticmethod
    def crossOver(_: "Geno", __2: "Geno") -> ExtValue:  # returns Geno
        "returns crossed over genotype"
        ...

    @staticmethod
    def getSimplest(format: str) -> ExtValue:  # returns Geno
        """
        Get simplest genotype

        returns the simplest genotype for a given encoding (format). "0" means f0, "4" means f4, etc.
        """
        ...

    @staticmethod
    def _propertyClear() -> ExtValue[None]:
        """
        Remove all properties

        Using most _property functions is restricted for internal purposes. Use "property:" or "state:" definitions in your script files to change object properties.
        """
        ...

    @staticmethod
    def _propertyAdd(id: str, type_description: str, name: str, flags: int, help_text: str) -> ExtValue[None]:
        """
        Add property (id,type,name,help)

        Using most _property functions is restricted for internal purposes. Use "property:" or "state:" definitions in your script files to change object properties.
        """
        ...

    @staticmethod
    def _propertyRemove(index: int) -> ExtValue[None]:
        """
        Remove property

        Using most _property functions is restricted for internal purposes. Use "property:" or "state:" definitions in your script files to change object properties.
        """
        ...

    @staticmethod
    def _propertyChange(id: str, type_description: str, name: str, flags: int, help_text: str) -> ExtValue[None]:
        """
        Change property

        Using most _property functions is restricted for internal purposes. Use "property:" or "state:" definitions in your script files to change object properties.
        """
        ...

    @staticmethod
    def _propertyAddGroup(name: str) -> ExtValue[None]:
        """
        Add property group

        Using most _property functions is restricted for internal purposes. Use "property:" or "state:" definitions in your script files to change object properties.
        """
        ...

    @staticmethod
    def _propertyRemoveGroup(index: int) -> ExtValue[None]:
        """
        Remove property group

        Using most _property functions is restricted for internal purposes. Use "property:" or "state:" definitions in your script files to change object properties.
        """
        ...

    @staticmethod
    def _propertyExists(name: str) -> ExtValue[int]:
        "Check for property existence"
        ...

    _property_changed_index: ExtValue[int]
    "Last changed property index"
    _property_changed_id: ExtValue[str]
    "Last changed property id"
    genoper_f0: ExtValue[int]
    "Operators for f0"
    genoper_f0s: ExtValue[int]
    "Operators for f0s"
    genoper_f1: ExtValue[int]
    "Operators for f1"
    genoper_f4: ExtValue[int]
    "Operators for f4"
    genoper_f8: ExtValue[int]
    "Operators for f8"
    genoper_f9: ExtValue[int]
    "Operators for f9"
    genoper_fF: ExtValue[int]
    "Operators for fF"
    genoper_fn: ExtValue[int]
    "Operators for fn"
    genoper_fB: ExtValue[int]
    "Operators for fB"
    genoper_fH: ExtValue[int]
    "Operators for fH"
    genoper_fL: ExtValue[int]
    "Operators for fL"
    genoper_fS: ExtValue[int]
    "Operators for fS"
    neuadd_N: ExtValue[int]
    """
    Neuron (N)
    
    Standard neuron
    
    Characteristics:
       supports any number of inputs
       provides output value
       does not require location in body
    
    
    Properties:
       Inertia (in) float 0..1 (default 0.8)
       Force (fo) float 0..999 (default 0.04)
       Sigmoid (si) float -99999..99999 (default 2)
       State (s) float -1..1 (default 0)
    """
    neuadd_Nu: ExtValue[int]
    """
    Unipolar neuron [EXPERIMENTAL!] (Nu)
    
    Works like standard neuron (N) but the output value is scaled to 0...+1 instead of -1...+1.
    Having 0 as one of the saturation states should help in "gate circuits", where input signal is passed through or blocked depending on the other singal.
    
    Characteristics:
       supports any number of inputs
       provides output value
       does not require location in body
    
    
    Properties:
       Inertia (in) float 0..1 (default 0.8)
       Force (fo) float 0..999 (default 0.04)
       Sigmoid (si) float -99999..99999 (default 2)
       State (s) float -1..1 (default 0)
    """
    neuadd_G: ExtValue[int]
    """
    Gyroscope (G)
    
    Tilt sensor.
    Signal is proportional to sin(angle) = most sensitive in horizontal orientation.
    0=the stick is horizontal
    +1/-1=the stick is vertical
    
    Characteristics:
       does not use inputs
       provides output value
       should be located on a Joint
    """
    neuadd_Gpart: ExtValue[int]
    """
    Part Gyroscope (Gpart)
    
    Tilt sensor. Signal is directly proportional to the tilt angle.
    0=the part X axis is horizontal
    +1/-1=the axis is vertical
    
    Characteristics:
       does not use inputs
       provides output value
       should be located on a Part
    
    
    Properties:
       rotation.y (ry) float -6.282..6.282 (default 0)
       rotation.z (rz) float -6.282..6.282 (default 0)
    """
    neuadd_T: ExtValue[int]
    """
    Touch (T)
    
    Touch and proximity sensor (Tcontact and Tproximity combined)
    -1=no contact
    0=just touching
    >0=pressing, value depends on the force applied (not implemented in ODE mode)
    
    Characteristics:
       does not use inputs
       provides output value
       should be located on a Part
    
    
    Properties:
       Range (r) float 0..1 (default 1)
       rotation.y (ry) float -6.282..6.282 (default 0)
       rotation.z (rz) float -6.282..6.282 (default 0)
    """
    neuadd_Tcontact: ExtValue[int]
    """
    Touch contact (Tcontact)
    
    Touch sensor.
    -1=no contact
    0=the Part is touching the obstacle
    >0=pressing, value depends on the force applied (not implemented in ODE mode)
    
    Characteristics:
       does not use inputs
       provides output value
       should be located on a Part
    """
    neuadd_Tproximity: ExtValue[int]
    """
    Touch proximity (Tproximity)
    
    Proximity sensor detecting obstacles along the X axis.
    -1=distance is "r" or more
    0=zero distance
    
    Characteristics:
       does not use inputs
       provides output value
       should be located on a Part
    
    
    Properties:
       Range (r) float 0..1 (default 1)
       rotation.y (ry) float -6.282..6.282 (default 0)
       rotation.z (rz) float -6.282..6.282 (default 0)
    """
    neuadd_S: ExtValue[int]
    """
    Smell (S)
    
    Smell sensor. Aggregated "smell of energy" experienced from all energy objects (creatures and food pieces).
    Close objects have bigger influence than the distant ones: for each energy source, its partial feeling is proportional to its energy/(distance^2)
    
    Characteristics:
       does not use inputs
       provides output value
       should be located on a Part
    """
    neuadd_Constant: ExtValue[int]
    """
    Constant (*)
    
    Constant value
    
    Characteristics:
       does not use inputs
       provides output value
       does not require location in body
    """
    neuadd_Bend_muscle: ExtValue[int]
    """
    Bend muscle (|)
    
    Characteristics:
       uses single input
       does not provide output value
       should be located on a Joint
    
    
    Properties:
       power (p) float 0..1 (default 0.25)
       bending range (r) float 0..1 (default 1)
    """
    neuadd_Rotation_muscle: ExtValue[int]
    """
    Rotation muscle (@)
    
    Characteristics:
       uses single input
       does not provide output value
       should be located on a Joint
    
    
    Properties:
       power (p) float 0..1 (default 1)
    """
    neuadd_M: ExtValue[int]
    """
    Muscle for solids (M)
    
    Characteristics:
       uses single input
       does not provide output value
       should be located on a Joint
    
    
    Properties:
       power (p) float 0..1 (default 1)
       axis (a) integer 0..1 (default 0)
    """
    neuadd_D: ExtValue[int]
    """
    Differentiate (D)
    
    Calculate the difference between the current and previous input value. Multiple inputs are aggregated with respect to their weights
    
    Characteristics:
       supports any number of inputs
       provides output value
       does not require location in body
    """
    neuadd_Fuzzy: ExtValue[int]
    """
    Fuzzy system [EXPERIMENTAL!] (Fuzzy)
    
    Refer to publications to learn more about this neuron.
    
    Characteristics:
       supports any number of inputs
       provides output value
       does not require location in body
    
    
    Properties:
       number of fuzzy sets (ns) integer
       number of rules (nr) integer
       fuzzy sets (fs) string (default "")
       fuzzy rules (fr) string (default "")
    """
    neuadd_VEye: ExtValue[int]
    """
    Vector Eye [EXPERIMENTAL!] (VEye)
    
    Refer to publications to learn more about this neuron.
    
    Characteristics:
       uses single input
       provides output value
       should be located on a Part
    
    
    Properties:
       target.x (tx) float
       target.y (ty) float
       target.z (tz) float
       target shape (ts) string (default "")
       perspective (p) float 0.1..10 (default 1)
       scale (s) float 0.1..100 (default 1)
       show hidden lines (h) integer 0..1 (default 0)
       output lines count (each line needs four channels) (o) integer 0..99 (default 0)
       debug (d) integer 0..1 (default 0)
    """
    neuadd_VMotor: ExtValue[int]
    """
    Visual-Motor Cortex [EXPERIMENTAL!] (VMotor)
    
    Must be connected to the VEye and properly set up. Refer to publications to learn more about this neuron.
    
    Characteristics:
       supports any number of inputs
       provides output value
       does not require location in body
    
    
    Properties:
       number of basic features (noIF) integer
       number of degrees of freedom (noDim) integer
       parameters (params) string
    """
    neuadd_Sti: ExtValue[int]
    """
    Sticky [EXPERIMENTAL!] (Sti)
    
    Characteristics:
       uses single input
       does not provide output value
       should be located on a Part
    """
    neuadd_LMu: ExtValue[int]
    """
    Linear muscle [EXPERIMENTAL!] (LMu)
    
    Characteristics:
       uses single input
       does not provide output value
       should be located on a Joint
    
    
    Properties:
       power (p) float 0.01..1 (default 1)
    """
    neuadd_Water: ExtValue[int]
    """
    Water detector (Water)
    
    Output signal:
    0=on or above water surface
    1=under water (deeper than 1)
    0..1=in the transient area just below water surface
    
    Characteristics:
       does not use inputs
       provides output value
       should be located on a Part
    """
    neuadd_Energy: ExtValue[int]
    """
    Energy level (Energy)
    
    The current energy level divided by the initial energy level.
    Usually falls from initial 1.0 down to 0.0 and then the creature dies. It can rise above 1.0 if enough food is ingested
    
    Characteristics:
       does not use inputs
       provides output value
       does not require location in body
    """
    neuadd_Ch: ExtValue[int]
    """
    Channelize (Ch)
    
    Combines all input signals into a single multichannel output; Note: ChSel and ChMux are the only neurons which support multiple channels. Other neurons discard everything except the first channel.
    
    Characteristics:
       supports any number of inputs
       provides output value
       does not require location in body
    """
    neuadd_ChMux: ExtValue[int]
    """
    Channel multiplexer (ChMux)
    
    Outputs the selected channel from the second (multichannel) input. The first input is used as the selector value (-1=select first channel, .., 1=last channel)
    
    Characteristics:
       uses 2 inputs
       provides output value
       does not require location in body
    """
    neuadd_ChSel: ExtValue[int]
    """
    Channel selector (ChSel)
    
    Outputs a single channel (selected by the "ch" parameter) from multichannel input
    
    Characteristics:
       uses single input
       provides output value
       does not require location in body
    
    
    Properties:
       channel (ch) integer
    """
    neuadd_Rnd: ExtValue[int]
    """
    Random noise (Rnd)
    
    Generates random noise (subsequent random values in the range of -1..+1)
    
    Characteristics:
       does not use inputs
       provides output value
       does not require location in body
    """
    neuadd_Sin: ExtValue[int]
    """
    Sinus generator (Sin)
    
    Output frequency = f0+input
    
    Characteristics:
       uses single input
       provides output value
       does not require location in body
    
    
    Properties:
       base frequency (f0) float -1..1 (default 0.0628319)
       time (t) float 0..6.28319 (default 0)
    """
    f0_nodel_tag: ExtValue[int]
    """
    Respect the 'delete inhibit' tag
    
    You can tag elements using their 'i' field and the i="mi=d" tag.
    Mutations will not delete such elements.
    The i="mi=dm" combination is allowed.
    """
    f0_nomod_tag: ExtValue[int]
    """
    Respect the 'modify inhibit' tag
    
    You can tag elements using their 'i' field and the i="mi=m" tag.
    Mutations will not modify properties of such elements.
    The i="mi=md" combination is allowed.
    """
    f0_p_new: ExtValue[float]
    "New part"
    f0_p_del: ExtValue[float]
    "Delete part"
    f0_p_swp: ExtValue[float]
    "Swap parts"
    f0_p_pos: ExtValue[float]
    "Position"
    f0_p_den: ExtValue[float]
    """
    Density
    
    Density only has an influence under water
    """
    f0_p_frc: ExtValue[float]
    "Friction"
    f0_p_ing: ExtValue[float]
    "Ingestion"
    f0_p_asm: ExtValue[float]
    """
    Assimilation
    
    The interpretation and influence of this property must be implemented by the experiment definition
    """
    f0_p_color: ExtValue[float]
    """
    Visual only: color
    
    If this value is above zero, apart from this mutation occurring, the color of every newly created gray Part will be mutated on creation
    """
    f0_j_new: ExtValue[float]
    "New joint"
    f0_j_del: ExtValue[float]
    "Delete joint"
    f0_j_stm: ExtValue[float]
    """
    Stamina
    
    The interpretation and influence of this property must be implemented by the experiment definition
    """
    f0_j_stf: ExtValue[float]
    "Stiffness"
    f0_j_rsf: ExtValue[float]
    "Rotational stiffness"
    f0_j_color: ExtValue[float]
    """
    Visual only: color
    
    If this value is above zero, apart from this mutation occurring, every newly created Joint will be assigned a color that is the average color of both joined Parts
    """
    f0_n_new: ExtValue[float]
    "New neuron"
    f0_n_del: ExtValue[float]
    "Delete neuron"
    f0_n_prp: ExtValue[float]
    "Change properties"
    f0_c_new: ExtValue[float]
    "New connection"
    f0_c_del: ExtValue[float]
    "Delete connection"
    f0_c_wei: ExtValue[float]
    "Change weight"
    f0s_nodel_tag: ExtValue[int]
    """
    Respect the 'delete inhibit' tag
    
    You can tag elements using their 'i' field and the i="mi=d" tag.
    Mutations will not delete such elements.
    The i="mi=dm" combination is allowed.
    """
    f0s_nomod_tag: ExtValue[int]
    """
    Respect the 'modify inhibit' tag
    
    You can tag elements using their 'i' field and the i="mi=m" tag.
    Mutations will not modify properties of such elements.
    The i="mi=md" combination is allowed.
    """
    f0s_circle_section: ExtValue[int]
    """
    Ensure circle section
    
    Ensure that ellipsoids and cylinders have circle cross-section
    """
    f0s_use_elli: ExtValue[int]
    "Use ellipsoids in mutations"
    f0s_use_cub: ExtValue[int]
    "Use cuboids in mutations"
    f0s_use_cyl: ExtValue[int]
    "Use cylinders in mutations"
    f0s_p_new: ExtValue[float]
    "New part"
    f0s_p_del: ExtValue[float]
    "Delete part"
    f0s_p_swp: ExtValue[float]
    "Swap parts"
    f0s_p_pos: ExtValue[float]
    "Position"
    f0s_p_rot: ExtValue[float]
    "Rotation"
    f0s_p_scale: ExtValue[float]
    "Size (precisely, 'scale')"
    f0s_p_frc: ExtValue[float]
    "Friction"
    f0s_p_ing: ExtValue[float]
    "Ingestion"
    f0s_p_asm: ExtValue[float]
    """
    Assimilation
    
    The interpretation and influence of this property must be implemented by the experiment definition
    """
    f0s_p_color: ExtValue[float]
    """
    Visual only: color
    
    If this value is above zero, apart from this mutation occurring, the color of every newly created gray Part will be mutated on creation
    """
    f0s_j_new: ExtValue[float]
    "New joint"
    f0s_j_del: ExtValue[float]
    "Delete joint"
    f0s_j_stm: ExtValue[float]
    """
    Stamina
    
    The interpretation and influence of this property must be implemented by the experiment definition
    """
    f0s_j_color: ExtValue[float]
    """
    Visual only: color
    
    If this value is above zero, apart from this mutation occurring, every newly created Joint will be assigned a color that is the average color of both joined Parts
    """
    f0s_n_new: ExtValue[float]
    "New neuron"
    f0s_n_del: ExtValue[float]
    "Delete neuron"
    f0s_n_prp: ExtValue[float]
    "Change properties"
    f0s_c_new: ExtValue[float]
    "New connection"
    f0s_c_del: ExtValue[float]
    "Delete connection"
    f0s_c_wei: ExtValue[float]
    "Change weight"
    f1_xo_propor: ExtValue[int]
    """
    Proportional crossover
    
    Cross over (exchange) corresponding segments of the two parent genotypes?
    
    f1 uses a two-point crossing over.
    If this option is turned on, cut points will be selected proportionally to neural genes in both parents, and a similar number of characters will be exchanged if possible.
    Thus, if both parents have the same number of neurons, then this will be preserved in their children.
    """
    f1_smX: ExtValue[float]
    "Add/remove a stick X"
    f1_smJunct: ExtValue[float]
    "Add/remove a branch ( )"
    f1_smComma: ExtValue[float]
    "Add/remove a comma ,"
    f1_smModif: ExtValue[float]
    """
    Add/remove a modifier
    
    Modifiers: LlRrCcQqFfMmEeWwSsAaIiDdGgBb
    """
    f1_smModifiers: ExtValue[str]
    """
    Allowed modifiers
    
    Modifier symbols that will be added or deleted during mutation
    (from the full set: LlRrCcQqFfMmEeWwSsAaIiDdGgBb).
    
    You may use the extended syntax: after every allowed symbol, you may include its probability value in parentheses.
    Without parentheses, all allowed symbols behave as if they had (1.0) appended.
    If you include (0.0) after a symbol, this bans that symbol as if it was not present in this string.
    """
    f1_nmNeu: ExtValue[float]
    """
    Add/remove a neuron
    
    Adds a (connected) neuron or removes a neuron
    """
    f1_nmConn: ExtValue[float]
    "Add/remove neural connection"
    f1_nmProp: ExtValue[float]
    "Add/remove neuron property setting"
    f1_nmWei: ExtValue[float]
    "Change connection weight"
    f1_nmVal: ExtValue[float]
    "Change property value"
    f4_mut_add: ExtValue[float]
    """
    Add node
    
    Mutation: probability of adding a node
    """
    f4_mut_add_div: ExtValue[float]
    """
    - add division
    
    Add node mutation: probability of adding a division
    """
    f4_mut_add_conn: ExtValue[float]
    """
    - add connection
    
    Add node mutation: probability of adding a neural connection
    """
    f4_mut_add_neupar: ExtValue[float]
    """
    - add neuron property
    
    Add node mutation: probability of adding a neuron property/modifier
    """
    f4_mut_add_rep: ExtValue[float]
    """
    - add repetition '#'
    
    Add node mutation: probability of adding the '#' repetition gene
    """
    f4_mut_add_simp: ExtValue[float]
    """
    - add simple node
    
    Add node mutation: probability of adding a random, simple gene
    """
    f4_mut_del: ExtValue[float]
    """
    Delete node
    
    Mutation: probability of deleting a node
    """
    f4_mut_mod: ExtValue[float]
    """
    Modify node
    
    Mutation: probability of changing a node
    """
    f4_mut_modneu_conn: ExtValue[float]
    """
    - neuron input: modify source
    
    Neuron input mutation: probability of changing its source neuron
    """
    f4_mut_modneu_weight: ExtValue[float]
    """
    - neuron input: modify weight
    
    Neuron input mutation: probability of changing its weight
    """
    f4_mut_max_rep: ExtValue[int]
    """
    Maximum number for '#' repetitions
    
    Maximum allowed number of repetitions for the '#' repetition gene
    """
    f4_mut_modifiers: ExtValue[str]
    """
    Allowed modifiers
    
    Modifier symbols that will be added or deleted during mutation
    (from the full set: LlRrCcQqFfMmEeWwSsAaIiDdGgBb).
    
    You may use the extended syntax: after every allowed symbol, you may include its probability value in parentheses.
    Without parentheses, all allowed symbols behave as if they had (1.0) appended.
    If you include (0.0) after a symbol, this bans that symbol as if it was not present in this string.
    """
    f8_mut_chg_begin_arg: ExtValue[float]
    """
    Change beginning argument
    
    mutation: probability of changing a beginning argument
    """
    f8_mut_chg_arg: ExtValue[float]
    """
    Change argument
    
    mutation: probability of changing a production's argument
    """
    f8_mut_del_comm: ExtValue[float]
    """
    Delete command
    
    mutation: probability of deleting a command
    """
    f8_mut_insert_comm: ExtValue[float]
    """
    Insert commands
    
    mutation: probability of inserting commands
    """
    f8_mut_enc: ExtValue[float]
    """
    Encapsulate commands
    
    mutation: probability of encapsulating commands
    """
    f8_mut_chg_cond_sign: ExtValue[float]
    """
    Change condition sign
    
    mutation: probability of changing a condition sign
    """
    f8_mut_add_param: ExtValue[float]
    """
    Add parameter
    
    mutation: probability of adding a parameter to the production
    """
    f8_mut_add_cond: ExtValue[float]
    """
    Add condition
    
    mutation: probability of adding a condition to the subproduction
    """
    f8_mut_add_subprod: ExtValue[float]
    """
    Add subproduction
    
    mutation: probability of adding a subproduction
    """
    f8_mut_chg_iter_number: ExtValue[float]
    """
    Change iteration number
    
    mutation: probability of changing a number of iterations
    """
    f8_mut_del_param: ExtValue[float]
    """
    Delete parameter
    
    mutation: probability of deleting a parameter
    """
    f8_mut_del_cond: ExtValue[float]
    """
    Delete condition
    
    mutation: probability of deleting a condition
    """
    f8_mut_add_loop: ExtValue[float]
    """
    Add loop
    
    mutation: probability of adding a loop
    """
    f8_mut_del_loop: ExtValue[float]
    """
    Delete loop
    
    mutation: probability of deleting a loop
    """
    f8_mut_del_prod: ExtValue[float]
    """
    Delete production
    
    mutation: probability of deleting a production
    """
    f9_mut: ExtValue[float]
    """
    Mutation probability
    
    How many genes should be mutated during a single mutation (1=all genes, 0.1=ten percent, 0=one gene)
    """
    fF_xover: ExtValue[float]
    """
    Inherited in linear mix crossover
    
    0.5 => children are averaged parents.
    0.8 => children are only 20% different from parents.
    1.0 => each child is identical to one parent (no crossover).
    """
    fn_xover: ExtValue[float]
    """
    Fraction inherited in linear mix crossover
    
    0.5 => children are averaged parents.
    0.8 => children are only 20% different from parents.
    1.0 => each child is identical to one parent (no crossover).
    """
    fn_xover_random: ExtValue[int]
    """
    Random fraction inherited in crossover
    
    If active, the amount of linear mix is random in each crossover operation, so the "Fraction inherited in linear mix crossover" parameter is ignored.
    """
    fn_mut_bound_low: ExtValue[str]
    """
    Lower bounds for mutation
    
    A vector of lower bounds (one real value for each variable)
    """
    fn_mut_bound_high: ExtValue[str]
    """
    Higher bounds for mutation
    
    A vector of higher bounds (one real value for each variable)
    """
    fn_mut_stddev: ExtValue[str]
    """
    Standard deviations for mutation
    
    A vector of standard deviations (one real value for each variable)
    """
    fn_mut_single_var: ExtValue[int]
    """
    Mutate only a single variable
    
    If active, only a single randomly selected variable will be mutated in each mutation operation. Otherwise all variables will be mutated.
    """
    fB_mut_substitute: ExtValue[float]
    """
    Substitution
    
    Relative probability of changing a single random character (or a neuron) in the genotype
    """
    fB_mut_insert: ExtValue[float]
    """
    Insertion
    
    Relative probability of inserting a random character in a random place of the genotype
    """
    fB_mut_insert_neuron: ExtValue[float]
    """
    Insertion of a neuron
    
    Relative probability of inserting a neuron in a random place of genotype
    """
    fB_mut_delete: ExtValue[float]
    """
    Deletion
    
    Relative probability of deleting a random character (or a neuron) in the genotype
    """
    fB_mut_duplicate: ExtValue[float]
    """
    Duplication
    
    Relative probability of copying a single *gene* of the genotype and appending it to the beginning of this genotype
    """
    fB_mut_translocate: ExtValue[float]
    """
    Translocation
    
    Relative probability of swapping two substrings in the genotype
    """
    fB_cross_gene_transfer: ExtValue[float]
    """
    Horizontal gene transfer
    
    Relative probability of crossing over by copying a single random gene from each parent to the beginning of the other parent
    """
    fB_cross_crossover: ExtValue[float]
    """
    Crossing over
    
    Relative probability of crossing over by a random distribution of genes from both parents to both children
    """
    fH_mut_addition: ExtValue[float]
    """
    Add element
    
    Probability of adding a new element
    """
    fH_mut_add_joint: ExtValue[float]
    """
    - add joint
    
    Probability of adding a new stick handle
    """
    fH_mut_add_neuron: ExtValue[float]
    """
    - add neuron
    
    Probability of adding a new neuron handle
    """
    fH_mut_add_connection: ExtValue[float]
    """
    - add neural connection
    
    Probability of adding a new neuron connection handle
    """
    fH_mut_deletion: ExtValue[float]
    """
    Delete element
    
    Probability of removing an element
    """
    fH_mut_handle: ExtValue[float]
    """
    Modify vectors of handles
    
    Probability of changing values in vectors of a handle
    """
    fH_mut_property: ExtValue[float]
    """
    Modify properties of handles
    
    Probability of changing properties of handles
    """
    fL_maxdefinedwords: ExtValue[int]
    """
    Maximum number of defined words
    
    Maximum number of words that can be defined in the L-System
    """
    fL_axm_mut_prob: ExtValue[float]
    """
    Axiom mutation
    
    Probability of performing mutation operations on axiom
    """
    fL_rul_mut_prob: ExtValue[float]
    """
    Rule's successor mutation
    
    Probability of performing mutation operations on the successor of a random rule
    """
    fL_mut_addition: ExtValue[float]
    """
    Addition of a word to a sequence
    
    Probability of adding a random existing word to the axiom or to one of successors
    """
    fL_mut_add_stick: ExtValue[float]
    """
    - addition of a stick
    
    Probability of adding a stick
    """
    fL_mut_add_neuro: ExtValue[float]
    """
    - addition of a neuron
    
    Probability of adding a neuron
    """
    fL_mut_add_conn: ExtValue[float]
    """
    - addition of a neuron connection
    
    Probability of adding a neuron connection
    """
    fL_mut_add_rot: ExtValue[float]
    """
    - addition of rotation words
    
    Probability of adding one of rotation words
    """
    fL_mut_add_branch: ExtValue[float]
    """
    - addition of a branched stick
    
    Probability of adding a branch with a rotation and a stick
    """
    fL_mut_add_other: ExtValue[float]
    """
    - addition of defined words
    
    Probability of adding another word defined in the genotype
    """
    fL_mut_worddefaddition: ExtValue[float]
    """
    Addition of a new word definition
    
    Probability of adding a new word definition to the genotype
    """
    fL_mut_ruleaddition: ExtValue[float]
    """
    Addition of a new rule definition
    
    Probability of adding a new rule definition for an existing word
    """
    fL_mut_rulecond: ExtValue[float]
    """
    Modification of a rule condition
    
    Probability of modifying a random rule condition
    """
    fL_mut_changeword: ExtValue[float]
    """
    Change a random word
    
    Probability of changing a word name or a formula of a random word from an axiom or one of successors
    """
    fL_mut_changeword_formula: ExtValue[float]
    """
    - change of a formula
    
    Probability of changing a formula in a word
    """
    fL_mut_changeword_name: ExtValue[float]
    """
    - change of a name
    
    Probability of changing a name in a word
    """
    fL_mut_changeiter: ExtValue[float]
    """
    Change the number of iterations
    
    Probability of changing the number of iterations of the L-System
    """
    fL_mut_changeiter_step: ExtValue[float]
    """
    Step of the iteration change
    
    The minimal step that should be used for changing iterations in the L-System
    """
    fL_mut_deletion: ExtValue[float]
    """
    Deletion of a random word
    
    Probability of deleting a random word from an axiom or a random successor (also deletes the rule if there is only one word in the successor)
    """
    fS_mut_add_part: ExtValue[float]
    """
    Add part
    
    mutation: probability of adding a part
    """
    fS_mut_rem_part: ExtValue[float]
    """
    Remove part
    
    mutation: probability of deleting a part
    """
    fS_mut_mod_part: ExtValue[float]
    """
    Modify part
    
    mutation: probability of changing the part type
    """
    fS_mut_change_joint: ExtValue[float]
    """
    Change joint
    
    mutation: probability of changing a joint
    """
    fS_mut_add_param: ExtValue[float]
    """
    Add param
    
    mutation: probability of adding a parameter
    """
    fS_mut_rem_param: ExtValue[float]
    """
    Remove param
    
    mutation: probability of removing a parameter
    """
    fS_mut_mod_param: ExtValue[float]
    """
    Modify param
    
    mutation: probability of modifying a parameter
    """
    fS_mut_mod_mod: ExtValue[float]
    """
    Modify modifier
    
    mutation: probability of modifying a modifier
    """
    fS_mut_add_neuro: ExtValue[float]
    """
    Add neuron
    
    mutation: probability of adding a neuron
    """
    fS_mut_rem_neuro: ExtValue[float]
    """
    Remove neuron
    
    mutation: probability of removing a neuron
    """
    fS_mut_mod_neuro_conn: ExtValue[float]
    """
    Modify neuron connection
    
    mutation: probability of changing a neuron connection
    """
    fS_mut_add_neuro_conn: ExtValue[float]
    """
    Add neuron connection
    
    mutation: probability of adding a neuron connection
    """
    fS_mut_rem_neuro_conn: ExtValue[float]
    """
    Remove neuron connection
    
    mutation: probability of removing a neuron connection
    """
    fS_mut_mod_neuro_params: ExtValue[float]
    """
    Modify neuron params
    
    mutation: probability of changing a neuron param
    """
    fS_circle_section: ExtValue[int]
    """
    Ensure circle section
    
    Ensure that ellipsoids and cylinders have circle cross-section
    """
    fS_use_elli: ExtValue[int]
    """
    Use ellipsoids in mutations
    
    Use ellipsoids in mutations
    """
    fS_use_cub: ExtValue[int]
    """
    Use cuboids in mutations
    
    Use cuboids in mutations
    """
    fS_use_cyl: ExtValue[int]
    """
    Use cylinders in mutations
    
    Use cylinders in mutations
    """
    fS_mut_add_part_strong: ExtValue[int]
    """
    Strong add part mutation
    
    Add part mutation will produce more parametrized parts
    """


class GenManStats(ExtValue):
    "Statistics for genetic operations."

    gen_count: ExtValue[int]
    "Number of genetic operations so far"
    gen_mvalid: ExtValue[int]
    "Mutations valid"
    gen_mvalidated: ExtValue[int]
    "Mutations validated"
    gen_minvalid: ExtValue[int]
    """
    Mutations invalid
    
    couldn't be repaired
    """
    gen_mfailed: ExtValue[int]
    """
    Mutations failed
    
    couldn't be performed
    """
    gen_xovalid: ExtValue[int]
    "Crossovers valid"
    gen_xovalidated: ExtValue[int]
    "Crossovers validated"
    gen_xoinvalid: ExtValue[int]
    """
    Crossovers invalid
    
    couldn't be repaired
    """
    gen_xofailed: ExtValue[int]
    """
    Crossovers failed
    
    couldn't be performed
    """
    gen_mutimpr: ExtValue[float]
    """
    Mutations total effect
    
    total cumulative mutation change
    """
    gen_xoimpr: ExtValue[float]
    """
    Crossovers total effect
    
    total cumulative crossover change
    """

    @staticmethod
    def clrstats() -> ExtValue[None]:
        "Clear stats and history"
        ...


class Geno(ExtValue):
    """
    All information about a single genotype.
    This is a genetics-only object which does not contain any performance data. See also: Genotype class
    """

    name: ExtValue[str]
    rawgenotype: ExtValue[str]
    """
    Raw genotype
    
    Genotype, excluding the format specifier
    """
    info: ExtValue[str]
    "Additional information or comments"
    format: ExtValue[str]
    "Genotype format"
    genotype: ExtValue[str]
    "Genes as a string of characters"
    isValid: ExtValue[int]
    """
    Valid
    
    Use 'is_valid' instead of 'isValid'.
    """
    is_valid: ExtValue[int]
    """
    Validity
    
    0 = invalid genotype
    1 = valid genotype
    -1 = validity is not known. This is a transient state. The value of "is_valid" will never be -1 when read. It is safe to treat is_valid as boolean in statements like "if (g.is_valid) ...". Setting "is_valid=-1" will make it 0 or 1 again. This third state (-1) is only needed for loading Genotype objects from files where the "is_valid" field might not be present.
    """

    @staticmethod
    def getConverted(format: str) -> ExtValue:  # returns Geno
        "Get converted genotype"
        ...

    @staticmethod
    def getConvertedWithCheckpoints(format: str) -> ExtValue:  # returns Geno
        """
        Get converted genotype

        See also Model.newWithCheckpoints()
        """
        ...

    f0genotype: ExtValue[str]
    """
    f0 genotype
    
    converted to f0 genotype
    """

    @staticmethod
    def new() -> ExtValue:  # returns Geno
        "create new empty object"
        ...

    @staticmethod
    def newFromString(genotype: str) -> ExtValue:  # returns Geno
        "create new object from supplied string argument"
        ...

    @staticmethod
    def newFrom(genotype: str, format: str, name: str, description: str) -> ExtValue:  # returns Geno
        "create new object"
        ...

    autoname: ExtValue[str]
    "Autogenerated name"
    toVector: ExtValue  # Vector
    "serialization support"

    @staticmethod
    def newFromVector(_: "Vector") -> ExtValue:  # returns Geno
        "serialization support"
        ...


class GenoConverters(ExtValue):
    "Converters between genetic formats"

    genoconv_f1_f0: ExtValue[int]
    "f1 --> f0  :  Recursive encoding"
    genoconv_f4_f0: ExtValue[int]
    "f4 --> f0  :  Developmental encoding"
    genoconv_f8_f1: ExtValue[int]
    "f8 --> f1  :  (Old) generative encoding"
    genoconv_f9_f0: ExtValue[int]
    "f9 --> f0  :  Turtle3D-ortho encoding"
    genoconv_fF_f0s: ExtValue[int]
    "fF --> f0s  :  10-parameter Foraminifera encoding"
    genoconv_fn_f0: ExtValue[int]
    "fn --> f0  :  Vector of real values, no phenotype"
    genoconv_fB_fH: ExtValue[int]
    "fB --> fH  :  Biological encoding"
    genoconv_fH_f0: ExtValue[int]
    "fH --> f0  :  Similarity encoding"
    genoconv_fL_f0: ExtValue[int]
    "fL --> f0  :  L-System encoding"
    genoconv_fS_f0s: ExtValue[int]
    "fS --> f0s  :  Solids tree-structure encoding"
    conv_f1_f0_modcompat: ExtValue[int]
    """
    Modifier compatibility
    
    The modern implementation makes the influence of modifiers more consistent and uniform, and the extreme property values are easier to reach with a lower number of characters, which improves the topology for evolutionary search.
    Previous implementation can be enabled for compatibility, for example when you want to test old genotypes.
    """
    conv_f1_f0_cq_influence: ExtValue[int]
    """
    'C' and 'Q' modifier influence
    
    'C' and 'Q' modifier semantics was changed in June 2023. Previously they did not affect the stick immediately following the current sequence of modifiers. In the modern implementation, all modifiers consistently start their influence at the very next stick that is being created in the current branch.
    Example:
    In the old interpretation of 'XcXX', only the last stick is rotated, because 'c' starts its influence at the stick that occurs after the current stick. In the modern implementation, the same effect is achieved with 'XXcX', where 'c' immediately bends the first 'X' that appears after it.
    Previous implementation can be enabled for compatibility, for example when you want to test old genotypes.
    """
    conv_f1_f0_branch_muscle_range: ExtValue[int]
    """
    Bending muscle default range
    
    Determines how the bending muscle default turning range is limited when the muscle is controlling a stick growing from a branching point that has 'NumberOfBranches' sticks separated by commas. The motivation of the limited range is to keep the neighboring sticks from intersecting when they are bent by muscles. This constraint may degrade the performance (e.g. velocity) of creatures, but this default value can be overridden by providing a specific range property value for the '|' muscle neuron in the genotype.
    - Full/NumberOfBranches - a compromise between the two other settings.
    - Full/(NumberOfBranches+1) - because the originating stick also counts as a branch. This setting guarantees that in the worst case, when at least two neighboring branches have sticks controlled by bending muscles and their controlling signals are at extreme values, the sticks can touch and overlap, but will not intersect. This setting is in most cases too strict because (1) all branches are very rarely controlled by muscles, (2) there are often 'empty' branches - multiple commas with no sticks in-between, and (3) the share of the originating stick is effectively wasted because this stick itself has no muscle at the branching point so it will not bend; the muscle bending range is symmetrical and the default range is equal for all muscles in a branching, but the sticks equipped with muscles in a branching are rarely evenly spaced.
    - Full: always the complete angle - because we do not have to care about the physical plausibility and avoid intersecting sticks, and other genetic representations do not impose such constraints, so this full angle setting can be useful as the default bending range when comparing the performance of various genetic encodings.
    """
    conv_f8_f1_maxlen: ExtValue[int]
    """
    Maximal genotype length
    
    Maximal length of the resulting f1 genotype, in characters. If the f8 L-system produces longer f1 genotype, it will be considered invalid.
    """


class Genotype(ExtValue):
    "A Genotype with the associated performance information. Adding genotypes to GenePool makes them accessible in Framsticks GUI and enables the use of GenePool selection methods. See also GenePools."

    name: ExtValue[str]
    genotype: ExtValue[str]
    "Genes as a string of characters."
    info_timestamp: ExtValue[float]
    "Last modified"
    info_author: ExtValue[str]
    "Author name"
    info_author_ispublic: ExtValue[int]
    "Author name is public"
    info_email: ExtValue[str]
    "Author email"
    info_email_ispublic: ExtValue[int]
    "Author email is public"
    info: ExtValue[str]
    """
    Description
    
    Short description of key features of this creature.
    """
    info_origin: ExtValue[int]
    """
    Origin
    
    Declaration of how this genotype originated.
    """
    info_how_created: ExtValue[str]
    """
    How created
    
    Description of the process of designing and/or evolving this genotype.
    """
    info_performance: ExtValue[str]
    """
    Performance notes
    
    Description of why this genotype is special/interesting and how it performs.
    """
    simi: ExtValue[float]
    """
    Similarity
    
    Average of 'dissimilarity(thisgeno,othergeno)' calculated for all other Genotype instances. This property is meant as fitness multiplier, included in the fitness function when similarity speciation (ExpProperties.cr_simi) is enabled.
    Read about details of dissimilarity calculation and its applications:
    http://www.framsticks.com/bib/Komosinski-et-al-2001
    http://www.framsticks.com/bib/Komosinski-and-Kubiak-2011
    http://www.framsticks.com/bib/Komosinski-2016
    """
    energ0: ExtValue[float]
    "Starting energy"
    energy0: ExtValue[float]
    "Starting energy"
    strsiz: ExtValue[int]
    "Body parts (deprecated; use numparts)"
    strjoints: ExtValue[int]
    "Body joints (deprecated; use numjoints)"
    nnsiz: ExtValue[int]
    "Brain size (deprecated; use numneurons)"
    nncon: ExtValue[int]
    "Brain connections (deprecated; use numconnections)"
    numparts: ExtValue[int]
    "Number of body Parts"
    numjoints: ExtValue[int]
    "Number of body Joints"
    numneurons: ExtValue[int]
    "Number of neurons"
    numconnections: ExtValue[int]
    "Number of neural connections"
    num: ExtValue[int]
    """
    Ordinal number
    
    Acts as a unique identifier, but less strict than "uid". Unlike "uid", "num" can be changed and therefore can be saved and restored, providing persistence and continuity beyond a single application run. "num" is only guaranteed to be unique if it is autogenerated and not changed by the user, otherwise it is user's responsibility to manage the proper values of "num". "Genotype.num" is generated on adding a Genotype object to a group, unless it already has a non-zero "num" (previously autogenerated or user-assigned). Autogenerated "num" is always equal to the largest previously used "num" + 1. The largest previously used value is stored in Simulator.last_genotype_num and can be changed as well (and is automatically saved and restored as a part of the Simulator state). Limitation: being a 32-bit integer, "num" overflows at about 2 billion counts.
    See also: uid
    """
    gnum: ExtValue[int]
    "Generation"
    popsiz: ExtValue[int]
    """
    Population size
    
    Please use 'instances' instead of 'popsiz'.
    """
    instances: ExtValue[int]
    "Copies of this genotype"
    lifespan: ExtValue[float]
    """
    Life span
    
    See Creature.lifespan
    """
    velocity: ExtValue[float]
    "See Creature.velocity"
    distance: ExtValue[float]
    "See Creature.distance"
    vertvel: ExtValue[float]
    """
    Vertical velocity
    
    See Creature.vertvel
    """
    vertpos: ExtValue[float]
    """
    Vertical position
    
    See Creature.vertpos
    """
    fit: ExtValue[float]
    "Fitness"
    fit2: ExtValue[float]
    """
    Final fitness
    
    Fitness shifted by (avg-n*stddev)
    """
    f0genotype: ExtValue[str]
    """
    f0 genotype
    
    converted to f0 genotype
    """
    convtrace1: ExtValue[str]
    "Conversion backtrace [1]"
    data: ExtValue  # Dictionary
    "Custom fields dictionary"
    user1: ExtValue  # untyped
    "User field 1"
    user2: ExtValue  # untyped
    "User field 2"
    user3: ExtValue  # untyped
    "User field 3"

    @staticmethod
    def mutate() -> ExtValue[None]: ...

    isValid: ExtValue[int]
    """
    Valid
    
    Use 'is_valid' instead of 'isValid'.
    """
    is_valid: ExtValue[int]
    """
    Validity
    
    0 = invalid genotype
    1 = valid genotype
    -1 = validity is not known. This is a transient state. The value of "is_valid" will never be -1 when read. It is safe to treat is_valid as boolean in statements like "if (g.is_valid) ...". Setting "is_valid=-1" will make it 0 or 1 again. This third state (-1) is only needed for loading Genotype objects from files where the "is_valid" field might not be present.
    """

    @staticmethod
    def getNormalized(property_name_or_index: Any) -> ExtValue[float]:
        "get normalized property"
        ...

    geno: ExtValue  # Geno
    "A Geno object for this Genotype"
    uid: ExtValue[str]
    """
    #
    
    Unique identifier that is generated on object creation. "uid" is only unique during a single application run. Subsequent runs generate the same sequence of uid values.
    See also: num
    """

    @staticmethod
    def getModel() -> ExtValue:  # returns Model
        "Model object"
        ...

    @staticmethod
    def splitInstances() -> ExtValue[None]:
        "split instances"
        ...

    @staticmethod
    def newFromString(genotype: str) -> ExtValue:  # returns Genotype
        "create new object"
        ...

    @staticmethod
    def newFromGeno(_: "Geno") -> ExtValue:  # returns Genotype
        "create new object"
        ...

    @staticmethod
    def newFromCreature(_: "Creature") -> ExtValue:  # returns Genotype
        "create new object"
        ...

    @staticmethod
    def addPerformanceFromCreature(_: "Creature") -> ExtValue[None]:
        "Updates the Genotype's performance values merging them with the supplied Creture's performance. It assumes the Genotype.instances has a reasonable value and performs the proper weighting. Use your own function instead if these conditions are not met in your experiment."
        ...

    @staticmethod
    def moveTo(pool: "GenePool") -> ExtValue[None]:
        """
        move to another gene pool

        the genotype is removed from its current pool when pool=null
        """
        ...

    @staticmethod
    def clone() -> ExtValue:  # returns Genotype
        """
        create a copy of the genotype

        Returns a duplicated genotype, not attached to any gene pool. All genotype fields are copied including 'data' (for which Dictionary.clone() produces a shallow copy).
        """
        ...

    @staticmethod
    def delete() -> ExtValue[None]:
        "remove from the pool"
        ...

    @staticmethod
    def deleteOne() -> ExtValue[None]:
        "delete single instance from the pool"
        ...

    genepool: ExtValue  # GenePool
    """
    gene pool
    
    GenePool object or null when not in pool
    """
    index: ExtValue[int]
    """
    current index in gene pool
    
    -1 when not in pool.
    Note that the index changes depending on the current genotype position in the pool. Use Genotype.uid if you need a permanent identifier that persists through the entire object lifetime.
    """

    @staticmethod
    def beforeLoad() -> ExtValue[None]:
        "Before loading"
        ...

    @staticmethod
    def afterLoad() -> ExtValue[None]:
        "After loading"
        ...


class Interface(ExtValue):
    """
    Used to query for object member descriptions. Examples:
      Simulator.print(Interface.makeFrom(Populations[0]).getType("perfperiod"));
      Simulator.print(Interface.makeFrom(Populations[0]).getMin("perfperiod"));
      Simulator.print(Interface.makeFrom(Populations[0]).getMax("perfperiod"));
      Simulator.print(Interface.makeFrom(Populations[0]).getDefault("perfperiod"));
      Simulator.print(Interface.makeFrom(Joint.*).getMax("dx"));
      Simulator.print(Interface.makeFrom(Part.*).getName("x"));
      Simulator.print(Interface.makeFrom(Creature.*).getHelp("idleen"));
      var iface=Interface.makeFrom(someobject); var description="This object has "+iface.size+" properties, first property is "+iface.getId(0);
    """

    name: ExtValue[str]
    "object name"
    size: ExtValue[int]
    "property count"
    groups: ExtValue[int]
    "group count"

    @staticmethod
    def get(index_or_id: Any) -> ExtValue:  # returns untyped
        "value of item"
        ...

    @staticmethod
    def getId(index_or_id: Any) -> ExtValue[str]:
        "id for item"
        ...

    @staticmethod
    def getName(index_or_id: Any) -> ExtValue[str]:
        "name for item"
        ...

    @staticmethod
    def getGroup(index_or_id: Any) -> ExtValue[int]:
        "group index for item"
        ...

    @staticmethod
    def getGroupName(index: int) -> ExtValue[str]:
        "group name for group index"
        ...

    @staticmethod
    def getType(index_or_id: Any) -> ExtValue[str]:
        "type for item"
        ...

    @staticmethod
    def getMin(index_or_id: Any) -> ExtValue[str]:
        "min value for item"
        ...

    @staticmethod
    def getMax(index_or_id: Any) -> ExtValue[str]:
        "max value for item"
        ...

    @staticmethod
    def getDefault(index_or_id: Any) -> ExtValue[str]:
        "default value for item"
        ...

    @staticmethod
    def getFlags(index_or_id: Any) -> ExtValue[int]:
        "flags for item"
        ...

    @staticmethod
    def getHelp(index_or_id: Any) -> ExtValue[str]:
        "help for item"
        ...

    @staticmethod
    def findId(name: str) -> ExtValue[int]:
        "item index having id"
        ...

    @staticmethod
    def findGroupId(name: str) -> ExtValue[int]:
        "group index for group name"
        ...

    @staticmethod
    def findIdInGroup(name: str, group_name_or_index: Any) -> ExtValue[int]:
        "item index for id in group"
        ...

    @staticmethod
    def makeFrom(_: "Object") -> ExtValue:  # returns Interface
        "get interface object"
        ...

    @staticmethod
    def set(index_or_id: Any, value: Any) -> ExtValue[None]:
        "set value of item"
        ...

    @staticmethod
    def setDefault(index_or_id: Any) -> ExtValue[None]:
        "set default value for item"
        ...

    @staticmethod
    def setAllDefault() -> ExtValue[None]:
        "set default values for all items"
        ...

    @staticmethod
    def invoke(function_name_or_index: Any, arguments: "Vector") -> ExtValue[None]:
        "invoke action"
        ...

    readonly: ExtValue[int]
    "d 0 1"

    @staticmethod
    def isReadonly(_: "Object") -> ExtValue[int]:
        "test if object is readonly"
        ...

    @staticmethod
    def makeReadonly(_: "Object") -> ExtValue:  # returns Object
        "make any object readonly"
        ...


class Joint(ExtValue):
    p1: ExtValue[int]
    "part1 ref#"
    p2: ExtValue[int]
    "part2 ref#"
    rx: ExtValue[float]
    "rotation.x"
    ry: ExtValue[float]
    "rotation.y"
    rz: ExtValue[float]
    "rotation.z"
    dx: ExtValue[float]
    "delta.x"
    dy: ExtValue[float]
    "delta.y"
    dz: ExtValue[float]
    "delta.z"
    sh: ExtValue[int]
    "shape"
    hx: ExtValue[float]
    "hinge position.x"
    hy: ExtValue[float]
    "hinge position.y"
    hz: ExtValue[float]
    "hinge position.z"
    hrx: ExtValue[float]
    "hinge rotation.x"
    hry: ExtValue[float]
    "hinge rotation.y"
    hrz: ExtValue[float]
    "hinge rotation.z"
    hxn: ExtValue[float]
    "hinge x negative limit"
    hxp: ExtValue[float]
    "hinge x positive limit"
    hyn: ExtValue[float]
    "hinge y negative limit"
    hyp: ExtValue[float]
    "hinge y positive limit"
    stif: ExtValue[float]
    "stiffness"
    rotstif: ExtValue[float]
    "rotation stiffness"
    stam: ExtValue[float]
    "stamina"
    i: ExtValue[str]
    "info"
    Vstyle: ExtValue[str]
    """
    Visual style
    
    See the "Visual style definition" context for more information
    """
    vr: ExtValue[float]
    "red component"
    vg: ExtValue[float]
    "green component"
    vb: ExtValue[float]
    "blue component"


class Loader(ExtValue):
    "Support for loading files in the Framsticks format. Used in the experiment definition to retrieve experiment state (see OnExpLoad function in standard.expdef). Registered objects (addClass) are handled automaticaly. Loader can call user functions defined by setBreakLabel."

    @staticmethod
    def addClass(_: "Object") -> ExtValue[None]:
        "add class definition"
        ...

    @staticmethod
    def removeClass(_: "Object") -> ExtValue[None]:
        "remove class definition"
        ...

    @staticmethod
    def clearClasses() -> ExtValue[None]:
        "remove all definitions"
        ...

    @staticmethod
    def go() -> ExtValue[int]:
        "load until next break"
        ...

    @staticmethod
    def run() -> ExtValue[int]:
        "continue loading"
        ...

    status: ExtValue[int]
    "loader status"
    comment: ExtValue[str]
    "last comment"

    @staticmethod
    def setBreak(break_conditions: int) -> ExtValue[None]:
        "define break condition"
        ...

    @staticmethod
    def setBreakLabel(break_condition: int, label: str) -> ExtValue[None]:
        "associate code label with the break condition"
        ...

    @staticmethod
    def abort() -> ExtValue[None]:
        "abort loading"
        ...

    currentObject: ExtValue  # Object
    "current object"
    objectName: ExtValue[str]
    "current object's class name"

    @staticmethod
    def loadObject() -> ExtValue[None]:
        "load current object"
        ...

    @staticmethod
    def skipObject() -> ExtValue[None]:
        "skip current object"
        ...

    firstComment: ExtValue[int]
    "first comment"
    BeforeObject: ExtValue[int]
    "BeforeObject break condition"
    AfterObject: ExtValue[int]
    "AfterObject break condition"
    BeforeUnknown: ExtValue[int]
    "BeforeUnknown break condition"
    OnComment: ExtValue[int]
    "OnComment break condition"
    OnError: ExtValue[int]
    "OnError break condition"


class Math(ExtValue):
    "Mathematical functions library."

    pi: ExtValue[float]
    "pi ~ 3.14"
    twopi: ExtValue[float]
    "2*pi ~ 6.28"
    pi2: ExtValue[float]
    "pi/2 ~ 1.57"
    pi4: ExtValue[float]
    "pi/4 ~ 0.78"

    @staticmethod
    def random(num: int) -> ExtValue[int]:
        """
        integer random number

        0..num-1
        """
        ...

    rnd01: ExtValue[float]
    "random number [0..1)"

    @staticmethod
    def rndUni(begin: float, end: float) -> ExtValue[float]:
        """
        random number (uniform distribution)

        [begin..end)
        """
        ...

    rndGaussStd: ExtValue[float]
    "random number (normal distribution)"

    @staticmethod
    def rndGauss(mean: float, standard_deviation: float) -> ExtValue[float]:
        """
        random number (selectable std.dev.)

        rndGaussStd is rndGauss(0,1)
        """
        ...

    @staticmethod
    def rndCustom(_: "Vector") -> ExtValue[float]:
        """
        random number

        the parameter describes the desired random distribution, being a sum of uniform distributions, eg. rndCustom([-10,-1, -1,1, 1,10]) defines 3 uniform distribution intervals [-1,10) [-1,1), [1,10)
        """
        ...

    seed: ExtValue[int]
    """
    random seed
    
    Random number generator seed.
    Note: Math.seed influences all further random activity in the simulator, not just the results of functions in this class.
    Note #2: When read, the value behaves just like a regular variable that stores the previously assigned value. It does NOT reflect the internal random generator seed that changes every time a random number has been generated.
    """

    @staticmethod
    def randomize():
        """
        set random seed

        Set random seed for the random number generator.
        """
        ...

    time: ExtValue[float]
    """
    current time
    
    Number of seconds since the Epoch (00:00:00 UTC/GMT, January 1, 1970)
    """

    @staticmethod
    def abs(_: float) -> ExtValue[float]:
        "absolute value"
        ...

    @staticmethod
    def sign(_: float) -> ExtValue[int]:
        "sign (-1, 0 or 1)"
        ...

    @staticmethod
    def sin(_: float) -> ExtValue[float]:
        "sinus"
        ...

    @staticmethod
    def cos(_: float) -> ExtValue[float]:
        "cosinus"
        ...

    @staticmethod
    def tan(_: float) -> ExtValue[float]:
        "tangent"
        ...

    @staticmethod
    def asin(_: float) -> ExtValue[float]:
        "arc sinus"
        ...

    @staticmethod
    def acos(_: float) -> ExtValue[float]:
        "arc cosinus"
        ...

    @staticmethod
    def atan(_: float) -> ExtValue[float]:
        "arc tangent"
        ...

    @staticmethod
    def atan2(y: float, x: float) -> ExtValue[float]:
        "arc tangent of y/x"
        ...

    @staticmethod
    def pow(a: float, b: float) -> ExtValue[float]:
        "power, a^b"
        ...

    @staticmethod
    def exp(_: float) -> ExtValue[float]:
        "exponent"
        ...

    @staticmethod
    def log(_: float) -> ExtValue[float]:
        "logarithm; base = e"
        ...

    @staticmethod
    def sqrt(_: float) -> ExtValue[float]:
        "square root"
        ...

    @staticmethod
    def sigmoid(_: float) -> ExtValue[float]:
        "sigmoid function = 2/(1+exp(-x))-1"
        ...

    @staticmethod
    def min(_: Any, __2: Any) -> ExtValue:  # returns untyped
        "minimum"
        ...

    @staticmethod
    def max(_: Any, __2: Any) -> ExtValue:  # returns untyped
        "maximum"
        ...


class MechJoint(ExtValue):
    rx: ExtValue[float]
    "rotation.x"
    ry: ExtValue[float]
    "rotation.y"
    rz: ExtValue[float]
    "rotation.z"
    dx: ExtValue[float]
    "delta.x"
    dy: ExtValue[float]
    "delta.y"
    dz: ExtValue[float]
    "delta.z"
    stif: ExtValue[float]
    "stiffness"
    rotstif: ExtValue[float]
    "rotation stiffness"
    part1: ExtValue  # MechPart
    "first part"
    part2: ExtValue  # MechPart
    "second part"
    stress: ExtValue[float]
    rotstress: ExtValue[float]
    joint: ExtValue  # Joint
    "corresponding Joint object"


class MechPart(ExtValue):
    x: ExtValue[float]
    "position.x"
    y: ExtValue[float]
    "position.y"
    z: ExtValue[float]
    "position.z"
    pos: ExtValue  # XYZ
    "position"
    m: ExtValue[float]
    """
    mass
    
    The mass of a MechPart is the same as the mass of its corresponding Part and cannot be changed. For f0, the mass of each Part is calculated as the number of its incident Joints. For f0s, the mass of each Part is calculated internally as its density*volume.
    """
    s: ExtValue[float]
    "size"
    vol: ExtValue[float]
    "volume"
    fr: ExtValue[float]
    "friction"
    vx: ExtValue[float]
    "velocity.x"
    vy: ExtValue[float]
    "velocity.y"
    vz: ExtValue[float]
    "velocity.z"
    v: ExtValue  # XYZ
    "velocity"
    orient: ExtValue  # Orient
    "orientation"
    oxx: ExtValue[float]
    "orientation.x.x"
    oxy: ExtValue[float]
    "orientation.x.y"
    oxz: ExtValue[float]
    "orientation.x.z"
    oyx: ExtValue[float]
    "orientation.y.x"
    oyy: ExtValue[float]
    "orientation.y.y"
    oyz: ExtValue[float]
    "orientation.y.z"
    ozx: ExtValue[float]
    "orientation.z.x"
    ozy: ExtValue[float]
    "orientation.z.y"
    ozz: ExtValue[float]
    "orientation.z.z"

    @staticmethod
    def applyForce(x: float, y: float, z: float) -> ExtValue[None]:
        "apply force"
        ...

    part: ExtValue  # Part
    "corresponding Part object"


class MessageCatcher(ExtValue):
    "Capture error messages."

    @staticmethod
    def new() -> ExtValue:  # returns MessageCatcher
        "create and deploy the new MessageCatcher"
        ...

    @staticmethod
    def close() -> ExtValue[None]:
        "stop using this MessageCatcher"
        ...

    store: ExtValue[int]
    "message storing options"
    error_count: ExtValue[int]
    "error count"
    error_warning_count: ExtValue[int]
    "error+warning count"
    error_warning_info_count: ExtValue[int]
    "error+warning+info count"
    warning_count: ExtValue[int]
    "warning count"
    info_count: ExtValue[int]
    "info count"
    stored_count: ExtValue[int]
    "number of stored messages"
    messages: ExtValue[str]
    "stored messages"
    summary: ExtValue[str]
    "error summary"


class Model(ExtValue):
    se: ExtValue[float]
    "startenergy"
    Vstyle: ExtValue[str]
    """
    Visual style
    
    See the "Visual style definition" context for more information
    """
    geno: ExtValue  # Geno

    @staticmethod
    def newFromString(genotype: str) -> ExtValue:  # returns Model
        "Create a new object"
        ...

    @staticmethod
    def newFromGeno(_: "Geno") -> ExtValue:  # returns Model
        "Create a new object"
        ...

    @staticmethod
    def newWithCheckpoints(Geno_object_or_string_genotype: Any) -> ExtValue:  # returns Model
        """
        Create a new object

        Creates a Model with the "Checkpoints" option enabled. Genotype converters supporting Checkpoints provide a sequence of Models that reflects development stages of the creature (this sequence is used purely for debugging and visualization of phenotype growth/development). Checkpoint Models can be accessed using getCheckpoint(i) for i ranging from 0 to numcheckpoints-1. Models created without the Checkpoint option and Models coming from unsupported converters have numcheckpoints=0.
        """
        ...

    numparts: ExtValue[int]
    "Number of parts"
    numjoints: ExtValue[int]
    "Number of joints"
    numneurons: ExtValue[int]
    "Number of neurons"
    numconnections: ExtValue[int]
    "Number of neuron connections"
    is_valid: ExtValue[int]
    "Validity"

    @staticmethod
    def getPart(index: int) -> ExtValue:  # returns Part
        "getPart (static model information)"
        ...

    @staticmethod
    def getJoint(index: int) -> ExtValue:  # returns Joint
        "getJoint (static model information)"
        ...

    @staticmethod
    def getNeuroDef(index: int) -> ExtValue:  # returns NeuroDef
        ...

    size_x: ExtValue[float]
    """
    Bounding box x size
    
    (size_x,size_y,size_z) are dimensions of the axis-aligned bounding box of the creature, including imaginary Part sizes (Part.s, usually 1.0). A creature consisting of a single default part has the size of (2.0,2.0,2.0) - twice the Part.s value (like a sphere diameter is twice its radius).
    See also: Creature.moveAbs
    """
    size_y: ExtValue[float]
    """
    Bounding box y size
    
    See Model.size_x
    """
    size_z: ExtValue[float]
    """
    Bounding box z size
    
    See Model.size_x
    """
    bboxSize: ExtValue  # XYZ
    "Bounding box size"
    numcheckpoints: ExtValue[int]
    "Number of checkpoints"

    @staticmethod
    def getCheckpoint(index: int) -> ExtValue:  # returns Model
        """
        Checkpoint Model objects are only valid as long as the parent Model object exists.
        See also: Model.newWithCheckpoints()

        // incorrect usage - calling getCheckpoint() on a temporary object:
        var c=Model.newWithCheckpoints("XXX").getCheckpoint(1).genotype.geno;

        // correct usage - keeping the parent Model reference in 'm':
        var m=Model.newWithCheckpoints("XXX");
        var c=m.getCheckpoint(1).genotype.geno;
        """
        ...

    shape_type: ExtValue[int]
    "Shape type"
    solid_model: ExtValue  # Model
    """
    Solid shapes model
    
    Conversion of this Model to solid shapes. Note! Only available when this Model has shape_type==2 (Ball-and-stick).
    """


class ModelGeometry(ExtValue):
    r"""
    Approximately estimates sizes, volume, and area of a Model based on the geometry of its parts.
    Example usage:
    Simulator.print(ModelGeometry.forModel(Model.newFromString("//0\np:sh=1\n")).area());

    ModelGeometry.geom_density refers to the global simulator parameter (also available in GUI).
    To set geom_density for individual ModelGeometry objects:
    var mg=ModelGeometry.forModel(GenePools[0][0].getModel()); mg.geom_density=2; GenePools[0][0].data->area=mg.area();
    """

    geom_density: ExtValue[float]
    """
    Density
    
    The number of samples (per unit length in one dimension) that affects the precision of estimation of geometrical properties.
    """

    @staticmethod
    def forModel(_: "Model") -> ExtValue:  # returns ModelGeometry
        "The returned ModelGeometry object can be used to calculate geometric properties (volume, area, sizes) of the associated model. The density is copied from the current global ModelGeometry.geom_density on object creation."
        ...

    @staticmethod
    def volume() -> ExtValue[float]: ...

    @staticmethod
    def area() -> ExtValue[float]: ...

    @staticmethod
    def voxels() -> ExtValue:  # returns Vector
        "Returns a Vector of Pt3D objects from a regular 3D grid (sampled according to ModelGeometry.geom_density) that are inside of the Model body (Parts and Joints)."
        ...

    @staticmethod
    def sizesAndAxes() -> ExtValue:  # returns Vector
        "The returned vector contains XYZ (sizes) and Orient (axes) objects."
        ...


class ModelSymmetry(ExtValue):
    "Calculates bilateral symmetry. Details are described in http://www.framsticks.com/bib/Jaskowski-and-Komosinski-2008"

    @staticmethod
    def calculateSymmetry(model: "Model") -> ExtValue[float]:
        """
        Calculate symmetry

        Returns bilateral symmetry (0.0 .. 1.0) for a given Model using default precision parameters (symPosSteps,symAlphaSteps,symBetaSteps). Returns the symmetry plane, too (sets symResultA,B,C,D).
        Note: may take a long time for large creatures.
        """
        ...

    @staticmethod
    def calculateSymmetry2(model: "Model", posSteps: int, alphaSteps: int, betaSteps: int) -> ExtValue[float]:
        """
        Calculate symmetry

        Returns bilateral symmetry (0.0 .. 1.0) for a given Model using specified precision parameters. Returns the symmetry plane, too (sets symResultA,B,C,D).
        Note: may take a long time for large creatures.
        """
        ...

    @staticmethod
    def calculateSymmetryForPlane(model: "Model", A: float, B: float, C: float, D: float) -> ExtValue[float]:
        """
        Calculate symmetry

        Returns bilateral symmetry (0.0 .. 1.0) for a given Model and given a specific plane defined by coefficients A, B, C, D.
        """
        ...

    symPosSteps: ExtValue[int]
    """
    Position sampling
    
    Default number of samples per stick length
    """
    symAlphaSteps: ExtValue[int]
    """
    Angular sampling (1)
    
    Default number of samples per full angle (#1)
    """
    symBetaSteps: ExtValue[int]
    """
    Angular sampling (2)
    
    Default number of samples per full angle (#2)
    """
    symResultA: ExtValue[float]
    "resulting symmetry plane, coeff. A (set by calculateSymmetry)"
    symResultB: ExtValue[float]
    "resulting symmetry plane, coeff. B (set by calculateSymmetry)"
    symResultC: ExtValue[float]
    "resulting symmetry plane, coeff. C (set by calculateSymmetry)"
    symResultD: ExtValue[float]
    "resulting symmetry plane, coeff. D (set by calculateSymmetry)"


class Neuro(ExtValue):
    "Live Neuron object."

    @staticmethod
    def getInputState(input: int) -> ExtValue[float]:
        "Get input signal"
        ...

    @staticmethod
    def getInputWeight(input: int) -> ExtValue[float]:
        "Get input weight"
        ...

    @staticmethod
    def getWeightedInputState(input: int) -> ExtValue[float]:
        "Get weighted input signal"
        ...

    @staticmethod
    def getInputSum(input: int) -> ExtValue[float]:
        "Get signal sum"
        ...

    @staticmethod
    def getWeightedInputSum(input: int) -> ExtValue[float]:
        """
        Get weighted signal sum

        Uses any number of inputs starting with the specified input. getWeightedInputSum(0)=weightedInputSum
        """
        ...

    getInputCount: ExtValue[int]
    "Get input count"
    inputSum: ExtValue[float]
    "Full signal sum"
    weightedInputSum: ExtValue[float]
    "Full weighted signal sum"

    @staticmethod
    def getInputChannelCount(input: int) -> ExtValue[int]:
        "Get channel count for input"
        ...

    @staticmethod
    def getInputStateChannel(input: int, channel: int) -> ExtValue[float]:
        "Get input signal from channel"
        ...

    @staticmethod
    def getWeightedInputStateChannel(input: int, channel: int) -> ExtValue[float]:
        "Get weighted input signal from channel"
        ...

    state: ExtValue[float]
    """
    Neuron state (channel 0)
    
    When read, returns the current neuron state.
    When written, sets the 'internal' neuron state that will become current in the next step.
    Typically you should use this field, and not currState.
    """
    channelCount: ExtValue[int]
    "Number of output channels"

    @staticmethod
    def getStateChannel(channel: int) -> ExtValue[float]:
        "Get state for channel"
        ...

    @staticmethod
    def setStateChannel(channel: int, value: float) -> ExtValue[None]:
        "Set state for channel"
        ...

    hold: ExtValue[int]
    """
    Hold state
    
    "Holding" means keeping the neuron state as is, blocking the regular neuron operation. This is useful when your script needs to inject some control signals into the NN. Without "holding", live neurons would be constantly overwriting your changes, and the rest of the NN could see inconsistent states, depending on the connections. Setting hold=1 ensures the neuron state will be only set by you, and not by the neuron. The enforced signal value can be set using Neuro.currState before or after setting hold=1. Set hold=0 to resume normal operation.
    """
    currState: ExtValue[float]
    """
    Current neuron state (channel 0)
    
    When read, it behaves just like the 'state' field.
    When written, changes the current neuron state immediately, which disturbs the regular synchronous NN operation.
    This feature should only be used while controlling the neuron 'from outside' (like a neuro probe) and not in the neuron definition. See also: Neuro.hold
    """

    @staticmethod
    def setCurrStateChannel(channel: int, value: float) -> ExtValue[None]:
        """
        Set current neuron state for channel

        Analogous to "currState".
        """
        ...

    position_x: ExtValue[float]
    "Position x"
    position_y: ExtValue[float]
    "Position y"
    position_z: ExtValue[float]
    "Position z"
    relative_pos: ExtValue  # XYZ
    "Relative position"
    relative_orient: ExtValue  # Orient
    "Relative orientation"
    creature: ExtValue  # Creature
    "Gets owner creature"
    mechpart: ExtValue  # MechPart
    "The MechPart object where this neuron is located"
    mechjoint: ExtValue  # MechJoint
    "The MechJoint object where this neuron is located"
    neuroproperties: ExtValue  # NeuroProperties
    """
    Custom neuron fields
    
    Neurons can have different fields depending on their class. Script neurons have their fields defined using the "property:" syntax. If you develop a custom neuron script you should use the NeuroProperties object for accessing your own neuron fields. The Neuro.neuroproperties property is meant for accessing the neuron fields from the outside script.
    Examples:
    var c=Populations.createFromString("X[N]");
    Simulator.print("standard neuron inertia="+c.getNeuro(0).neuroproperties.in);
    c=Populations.createFromString("X[Nn,e:0.1]");
    Simulator.print("noisy neuron error rate="+c.getNeuro(0).neuroproperties.e);
    
    The Interface object can be used to discover which fields are available for a certain neuron object:
    c=Populations.createFromString("X[N]");
    var iobj=Interface.makeFrom(c.getNeuro(0).neuroproperties);
    var i;
    for(i=0;i<iobj.size;i++)
     Simulator.print(iobj.getId(i)+" ("+iobj.getName(i)+")");
    """
    def_: ExtValue  # NeuroDef
    "Neuron definition from which this live neuron was built"
    classObject: ExtValue  # NeuroClass
    "Neuron class for this neuron"
    signals: ExtValue  # NeuroSignals


class NeuroClass(ExtValue):
    "The static NeuroClass object refers to the class selected in the NeuroClassLibrary. Most, but not all, properties have direct counterparts in *.neuro files that define custom neuron classes."

    name: ExtValue[str]
    """
    Class name
    
    Used in genotypes
    """
    longname: ExtValue[str]
    """
    Long, human readable name
    
    Used in hints
    """
    description: ExtValue[str]
    "Long description"
    prefinputs: ExtValue[int]
    """
    Preferred number of inputs
    
    -1 means "any number of inputs is OK"
    """
    prefoutput: ExtValue[int]
    """
    Provides output
    
    Should be 1 if the neuron provides meaningful output value, 0 otherwise
    """
    preflocation: ExtValue[int]
    "Preferred body location"
    shape_types: ExtValue[int]
    """
    Supported model shape types
    
    Bit mask of supported (1<<Model::ShapeType) values, default 3=all shape types supported
    """
    joint_shapes: ExtValue[int]
    """
    Supported joint shapes
    
    Bit mask of supported (1<<Joint::Shape) values, default 15=all joint shapes supported
    """
    visualhints: ExtValue[int]
    """
    Visual hints
    
    This is a bitfield. Compute the value by adding the following bits:
    1 = Invisible - don't draw neurons of this class
    2 = No label - don't draw classname label (below the neuron symbol) for this neuron class
    4 = First Part - draw the neuron at the first part when attached to a joint (default is in the middle)
    8 = Second Part - draw the neuron at the second part when attached to a joint (default is in the middle)
    16 = Effector - use muscle color when drawing this neuron
    32 = Sensor - use receptor color when drawing this neuron
    Compatiblity: visualhints is called "vhints" in *.neuro files.
    """
    glyph: ExtValue[str]
    """
    Glyph vector data
    
    <html>The neuron icon for use in NN diagrams, encoded as a comma-separated sequence of integer numbers.<ul>
    <li>N = the total number of all numbers following this one
    <li>NS = the number of line sequences<br>
    <ul>repeated NS times:
    <li>NL = number of line segments (creating a polyline)
    <li><span style="background-color:#fcc;">X,Y</span> (repeated NL+1 times) - subsequent line segment coordinates, each line should fit in a 100x100 square<br>
    - neuron input connections will be drawn at X=25 (varying Y for multiple inputs, Y=50 for a single input)<br>
    - neuron output connection will be drawn at (X=75,Y=50)
    </ul></ul>
    <p>Example:
    <table border=1>
    <tr><th>16,</th><th>2,</th><th>3,</th><th><span style="background-color:#fcc;">25,50</span>, <span style="background-color:#fcc;">40,30</span>, <span style="background-color:#fcc;">60,30</span>, <span style="background-color:#fcc;">75,50</span>,</th><th>1,</th><th><span style="background-color:#fcc;">40,50</span>, <span style="background-color:#fcc;">60,50</span></th></tr>
    <tr><td>N = 16 numbers following this one</td><td>NS = 2 line sequences</td><td>NL = the first sequence has 3 segments</td><td>coordinates for 3 line segments = 4 endpoints = 8 numbers</td><td>NL = the second sequence has 1 segment</td><td>coordinates for 1 line segment</td></tr>
    </table>
    <p>See also: <a href="http://www.framsticks.com/files/dev/files/inkscape-to-icon.html">a script for creating *.neuro icon from SVG</a><br>
    Compatibility: this field is called "icon" in *.neuro files.
    """
    properties: ExtValue  # Interface
    """
    Interface object connected with neuron class properties
    
    Compatibility: not preset in *.neuro files.
    """
    summary: ExtValue[str]
    """
    Textual summary of all features.
    Compatibility: not preset in *.neuro files.
    """


class NeuroClassLibrary(ExtValue):
    "Set of Neuron classes. You can access the selected class in the static NeuroClass object."

    count: ExtValue[int]
    "class count"
    class_: ExtValue[int]
    """
    current class
    
    0 ... count-1
    """

    @staticmethod
    def findClass(class_name: str) -> ExtValue[None]:
        "select class by name"
        ...

    @staticmethod
    def getClass(class_name: str) -> ExtValue:  # returns NeuroClass
        "get class object by name"
        ...


class NeuroDef(ExtValue):
    p: ExtValue[int]
    "part ref#"
    j: ExtValue[int]
    "joint ref#"
    d: ExtValue[str]
    "details"
    i: ExtValue[str]
    "info"
    Vstyle: ExtValue[str]
    """
    Visual style
    
    See the "Visual style definition" context for more information
    """
    getInputCount: ExtValue[int]
    "input count"

    @staticmethod
    def getInputNeuroDef(_: int) -> ExtValue:  # returns NeuroDef
        "get input neuron"
        ...

    @staticmethod
    def getInputNeuroIndex(_: int) -> ExtValue[int]:
        "get input neuron index"
        ...

    @staticmethod
    def getInputWeight(_: int) -> ExtValue[float]:
        "get input weight"
        ...

    classObject: ExtValue  # NeuroClass
    "neuron class"


class NeuronsSimEnabled(ExtValue):
    ncl_N: ExtValue[int]
    """
    Neuron (N)
    
    Standard neuron
    
    Characteristics:
       supports any number of inputs
       provides output value
       does not require location in body
    
    
    Properties:
       Inertia (in) float 0..1 (default 0.8)
       Force (fo) float 0..999 (default 0.04)
       Sigmoid (si) float -99999..99999 (default 2)
       State (s) float -1..1 (default 0)
    """
    ncl_Nu: ExtValue[int]
    """
    Unipolar neuron [EXPERIMENTAL!] (Nu)
    
    Works like standard neuron (N) but the output value is scaled to 0...+1 instead of -1...+1.
    Having 0 as one of the saturation states should help in "gate circuits", where input signal is passed through or blocked depending on the other singal.
    
    Characteristics:
       supports any number of inputs
       provides output value
       does not require location in body
    
    
    Properties:
       Inertia (in) float 0..1 (default 0.8)
       Force (fo) float 0..999 (default 0.04)
       Sigmoid (si) float -99999..99999 (default 2)
       State (s) float -1..1 (default 0)
    """
    ncl_G: ExtValue[int]
    """
    Gyroscope (G)
    
    Tilt sensor.
    Signal is proportional to sin(angle) = most sensitive in horizontal orientation.
    0=the stick is horizontal
    +1/-1=the stick is vertical
    
    Characteristics:
       does not use inputs
       provides output value
       should be located on a Joint
    """
    ncl_Gpart: ExtValue[int]
    """
    Part Gyroscope (Gpart)
    
    Tilt sensor. Signal is directly proportional to the tilt angle.
    0=the part X axis is horizontal
    +1/-1=the axis is vertical
    
    Characteristics:
       does not use inputs
       provides output value
       should be located on a Part
    
    
    Properties:
       rotation.y (ry) float -6.282..6.282 (default 0)
       rotation.z (rz) float -6.282..6.282 (default 0)
    """
    ncl_T: ExtValue[int]
    """
    Touch (T)
    
    Touch and proximity sensor (Tcontact and Tproximity combined)
    -1=no contact
    0=just touching
    >0=pressing, value depends on the force applied (not implemented in ODE mode)
    
    Characteristics:
       does not use inputs
       provides output value
       should be located on a Part
    
    
    Properties:
       Range (r) float 0..1 (default 1)
       rotation.y (ry) float -6.282..6.282 (default 0)
       rotation.z (rz) float -6.282..6.282 (default 0)
    """
    ncl_Tcontact: ExtValue[int]
    """
    Touch contact (Tcontact)
    
    Touch sensor.
    -1=no contact
    0=the Part is touching the obstacle
    >0=pressing, value depends on the force applied (not implemented in ODE mode)
    
    Characteristics:
       does not use inputs
       provides output value
       should be located on a Part
    """
    ncl_Tproximity: ExtValue[int]
    """
    Touch proximity (Tproximity)
    
    Proximity sensor detecting obstacles along the X axis.
    -1=distance is "r" or more
    0=zero distance
    
    Characteristics:
       does not use inputs
       provides output value
       should be located on a Part
    
    
    Properties:
       Range (r) float 0..1 (default 1)
       rotation.y (ry) float -6.282..6.282 (default 0)
       rotation.z (rz) float -6.282..6.282 (default 0)
    """
    ncl_S: ExtValue[int]
    """
    Smell (S)
    
    Smell sensor. Aggregated "smell of energy" experienced from all energy objects (creatures and food pieces).
    Close objects have bigger influence than the distant ones: for each energy source, its partial feeling is proportional to its energy/(distance^2)
    
    Characteristics:
       does not use inputs
       provides output value
       should be located on a Part
    """
    ncl_Constant: ExtValue[int]
    """
    Constant (*)
    
    Constant value
    
    Characteristics:
       does not use inputs
       provides output value
       does not require location in body
    """
    ncl_Bend_muscle: ExtValue[int]
    """
    Bend muscle (|)
    
    Characteristics:
       uses single input
       does not provide output value
       should be located on a Joint
    
    
    Properties:
       power (p) float 0..1 (default 0.25)
       bending range (r) float 0..1 (default 1)
    """
    ncl_Rotation_muscle: ExtValue[int]
    """
    Rotation muscle (@)
    
    Characteristics:
       uses single input
       does not provide output value
       should be located on a Joint
    
    
    Properties:
       power (p) float 0..1 (default 1)
    """
    ncl_M: ExtValue[int]
    """
    Muscle for solids (M)
    
    Characteristics:
       uses single input
       does not provide output value
       should be located on a Joint
    
    
    Properties:
       power (p) float 0..1 (default 1)
       axis (a) integer 0..1 (default 0)
    """
    ncl_D: ExtValue[int]
    """
    Differentiate (D)
    
    Calculate the difference between the current and previous input value. Multiple inputs are aggregated with respect to their weights
    
    Characteristics:
       supports any number of inputs
       provides output value
       does not require location in body
    """
    ncl_Fuzzy: ExtValue[int]
    """
    Fuzzy system [EXPERIMENTAL!] (Fuzzy)
    
    Refer to publications to learn more about this neuron.
    
    Characteristics:
       supports any number of inputs
       provides output value
       does not require location in body
    
    
    Properties:
       number of fuzzy sets (ns) integer
       number of rules (nr) integer
       fuzzy sets (fs) string (default "")
       fuzzy rules (fr) string (default "")
    """
    ncl_VEye: ExtValue[int]
    """
    Vector Eye [EXPERIMENTAL!] (VEye)
    
    Refer to publications to learn more about this neuron.
    
    Characteristics:
       uses single input
       provides output value
       should be located on a Part
    
    
    Properties:
       target.x (tx) float
       target.y (ty) float
       target.z (tz) float
       target shape (ts) string (default "")
       perspective (p) float 0.1..10 (default 1)
       scale (s) float 0.1..100 (default 1)
       show hidden lines (h) integer 0..1 (default 0)
       output lines count (each line needs four channels) (o) integer 0..99 (default 0)
       debug (d) integer 0..1 (default 0)
    """
    ncl_VMotor: ExtValue[int]
    """
    Visual-Motor Cortex [EXPERIMENTAL!] (VMotor)
    
    Must be connected to the VEye and properly set up. Refer to publications to learn more about this neuron.
    
    Characteristics:
       supports any number of inputs
       provides output value
       does not require location in body
    
    
    Properties:
       number of basic features (noIF) integer
       number of degrees of freedom (noDim) integer
       parameters (params) string
    """
    ncl_Sti: ExtValue[int]
    """
    Sticky [EXPERIMENTAL!] (Sti)
    
    Characteristics:
       uses single input
       does not provide output value
       should be located on a Part
    """
    ncl_LMu: ExtValue[int]
    """
    Linear muscle [EXPERIMENTAL!] (LMu)
    
    Characteristics:
       uses single input
       does not provide output value
       should be located on a Joint
    
    
    Properties:
       power (p) float 0.01..1 (default 1)
    """
    ncl_Water: ExtValue[int]
    """
    Water detector (Water)
    
    Output signal:
    0=on or above water surface
    1=under water (deeper than 1)
    0..1=in the transient area just below water surface
    
    Characteristics:
       does not use inputs
       provides output value
       should be located on a Part
    """
    ncl_Energy: ExtValue[int]
    """
    Energy level (Energy)
    
    The current energy level divided by the initial energy level.
    Usually falls from initial 1.0 down to 0.0 and then the creature dies. It can rise above 1.0 if enough food is ingested
    
    Characteristics:
       does not use inputs
       provides output value
       does not require location in body
    """
    ncl_Ch: ExtValue[int]
    """
    Channelize (Ch)
    
    Combines all input signals into a single multichannel output; Note: ChSel and ChMux are the only neurons which support multiple channels. Other neurons discard everything except the first channel.
    
    Characteristics:
       supports any number of inputs
       provides output value
       does not require location in body
    """
    ncl_ChMux: ExtValue[int]
    """
    Channel multiplexer (ChMux)
    
    Outputs the selected channel from the second (multichannel) input. The first input is used as the selector value (-1=select first channel, .., 1=last channel)
    
    Characteristics:
       uses 2 inputs
       provides output value
       does not require location in body
    """
    ncl_ChSel: ExtValue[int]
    """
    Channel selector (ChSel)
    
    Outputs a single channel (selected by the "ch" parameter) from multichannel input
    
    Characteristics:
       uses single input
       provides output value
       does not require location in body
    
    
    Properties:
       channel (ch) integer
    """
    ncl_Rnd: ExtValue[int]
    """
    Random noise (Rnd)
    
    Generates random noise (subsequent random values in the range of -1..+1)
    
    Characteristics:
       does not use inputs
       provides output value
       does not require location in body
    """
    ncl_Sin: ExtValue[int]
    """
    Sinus generator (Sin)
    
    Output frequency = f0+input
    
    Characteristics:
       uses single input
       provides output value
       does not require location in body
    
    
    Properties:
       base frequency (f0) float -1..1 (default 0.0628319)
       time (t) float 0..6.28319 (default 0)
    """


class NeuroSignals(ExtValue):
    """
    Signals attached to a neuron.
    See also: Signal, WorldSignals, CreatureSignals.
    scripts/light.neuro and scripts/seelight.neuro are simple custom neuron examples demonstrating how to send/receive signals between creatures.
    """

    @staticmethod
    def add(channel: str) -> ExtValue:  # returns Signal
        "Create a new signal"
        ...

    @staticmethod
    def receive(channel: str) -> ExtValue[float]:
        """
        Receive signal in channel

        Receive the aggregated signal power in a given channel.
        """
        ...

    @staticmethod
    def receiveSet(channel: str, max_distance: float) -> ExtValue:  # returns Vector
        """
        Receive signals in range

        Get all signals in the specified range. Returns a read-only vector object containing Signal objects - individual signals can be accessed as result[0], .., result[result.size-1].
        """
        ...

    @staticmethod
    def receiveFilter(channel: str, max_distance: float, flavor: float, flavorfilter: float) -> ExtValue[float]:
        """
        Receive filtered signal

        Receive the aggregated signal power in a given channel.

        Additional filtering options:
        - Max distance only receives the neighbor signals (based on their physical location)
        - Flavor filtering: only signals having the flavor similar to the specified value will be received. The flavorfilter value is the difference of flavor that reduces the received signal to 0. The "flavor attenuation" is linear, i.e., signals differing by (filter/2) in flavor will be reduced to 50%.
        """
        ...

    @staticmethod
    def receiveSingle(channel: str, max_distance: float) -> ExtValue:  # returns Signal
        """
        Receive strongest

        Find the signal source that has the highest signal power (taking into account distance).
        """
        ...

    @staticmethod
    def get(index: int) -> ExtValue:  # returns Signal
        "Access individual signals (index = 0 .. size-1)"
        ...

    size: ExtValue[int]
    "Number of signals in this set"

    @staticmethod
    def clear() -> ExtValue[None]:
        "Delete all signals"
        ...


class ODE(ExtValue):
    "ODE Parameters."

    odeshape: ExtValue[int]
    "Stick shape for ball-and-stick models"
    odestep: ExtValue[float]
    "Simulation step"
    odemusclemin: ExtValue[float]
    """
    Muscle min power
    
    i.e. "mmmmm" in f1
    """
    odemusclemax: ExtValue[float]
    """
    Muscle max power
    
    i.e. "MMMMM" if f1
    """
    odemusclespeed: ExtValue[float]
    """
    Muscle speed limit
    
    Muscle state cannot change faster than the supplied value
    """
    odeairdrag: ExtValue[float]
    """
    Drag
    
    A drag force ("air drag") proportional to the velocity of mass centers of moving parts (ODE's "linear damping")
    """
    oderotdrag: ExtValue[float]
    """
    Rotation drag
    
    Drag momentum acting on rotating bodies (ODE's "angular damping")
    """
    odewaterdrag: ExtValue[float]
    "Water drag"
    odewaterbuoy: ExtValue[float]
    "Water buoyancy"
    odeseed: ExtValue[int]
    """
    Randomness
    
    Affects collisions.
    - 'Truly random' is closest to the standard ODE operation. Use Math.seed to influence randomness in ODE collisions.
    - 'Deterministic' automatically calculates random seed in each step based on the current simulation (world) state, which makes the simulation repeatable but more random than 'Fixed'.
    - 'Fixed' is completely deterministic and does not depend on Math.seed - the same seed value is set before each step. This might negatively affect ODE accuracy.
    """
    odesepsticks: ExtValue[int]
    """
    Separate sticks
    
    Each stick gets a separate ODE body (like in MechaStick)
    """
    odeworlderp: ExtValue[float]
    """
    ERP
    
    World ERP (error reduction parameter)
    """
    odeworldcfm: ExtValue[float]
    """
    CFM
    
    World CFM (constraint force mixing)
    """
    odecolmumin: ExtValue[float]
    """
    Min. friction
    
    Mu coefficient for Parts with minimal friction (i.e. "fffff" in f1)
    """
    odecolmumax: ExtValue[float]
    """
    Max. friction
    
    Mu coefficient for Parts with maximal friction (i.e. "FFFFF" in f1)
    """
    odecolbounce: ExtValue[float]
    "Bounce"
    odecolbouncevel: ExtValue[float]
    "Bounce velocity"
    odecolsoftcfm: ExtValue[float]
    "Soft CFM"
    odecolsofterp: ExtValue[float]
    "Soft ERP"
    odecol2mumin: ExtValue[float]
    """
    Min. friction
    
    Mu coefficient for Parts with minimal friction (i.e. "fffff" in f1)
    """
    odecol2mumax: ExtValue[float]
    """
    Max. friction
    
    Mu coefficient for Parts with maximal friction (i.e. "FFFFF" in f1)
    """
    odecol2bounce: ExtValue[float]
    "Bounce"
    odecol2bouncevel: ExtValue[float]
    "Bounce velocity"
    odecol2softcfm: ExtValue[float]
    "Soft CFM"
    odecol2softerp: ExtValue[float]
    "Soft ERP"

    @staticmethod
    def rayIntersection(
        position_x: float,
        position_y: float,
        position_z: float,
        direction_x: float,
        direction_y: float,
        direction_z: float,
        max_distance: float,
    ) -> ExtValue[float]:
        "ray intersection"
        ...


class Orient(ExtValue):
    "3D orientation, stored as 3x3 matrix."

    xx: ExtValue[float]
    "orientation.x.x"
    xy: ExtValue[float]
    "orientation.x.y"
    xz: ExtValue[float]
    "orientation.x.z"
    yx: ExtValue[float]
    "orientation.y.x"
    yy: ExtValue[float]
    "orientation.y.y"
    yz: ExtValue[float]
    "orientation.y.z"
    zx: ExtValue[float]
    "orientation.z.x"
    zy: ExtValue[float]
    "orientation.z.y"
    zz: ExtValue[float]
    "orientation.z.z"
    x: ExtValue  # XYZ
    "x vector"
    y: ExtValue  # XYZ
    "y vector"
    z: ExtValue  # XYZ
    "z vector"

    @staticmethod
    def new() -> ExtValue:  # returns Orient
        "create new Orient object"
        ...

    @staticmethod
    def newFromVector(_: "Vector") -> ExtValue:  # returns Orient
        "create new Orient object"
        ...

    toVector: ExtValue  # Vector
    """
    vector representation
    
    for serialization
    """

    @staticmethod
    def clone() -> ExtValue:  # returns Orient
        "create new Orient object"
        ...

    @staticmethod
    def set(_: "Orient") -> ExtValue[None]:
        "copy from another Orient object"
        ...

    @staticmethod
    def reset() -> ExtValue[None]:
        "set identity matrix"
        ...

    @staticmethod
    def rotate3(x: float, y: float, z: float) -> ExtValue[None]:
        "rotate around 3 axes"
        ...

    @staticmethod
    def rotate(_: "Orient") -> ExtValue[None]:
        "rotate using Orient object"
        ...

    @staticmethod
    def revRotate(_: "Orient") -> ExtValue[None]:
        "reverse rotate using Orient object"
        ...

    @staticmethod
    def lookAt(direction: "XYZ", up: "XYZ") -> ExtValue[None]:
        "calculate rotation from 2 vectors"
        ...

    @staticmethod
    def normalize() -> ExtValue[None]: ...

    @staticmethod
    def between2(_: "Orient", __2: "Orient", amount: float) -> ExtValue[None]:
        """
        interpolate orientation

        The calling Orient receives the orientation interpolated from 2 input orientations.
        Example:
        var o1=Orient.new(), o2=Orient.new(), o3=Orient.new();
        o2.rotate3(0,Math.pi/2,0);
        o3.between2(o1,o2,0); // o3 equals o2
        o3.between2(o1,o2,1); // o3 equals o1
        o3.between2(o1,o2,0.5); // o3 is halfway between o1 and o2
        """
        ...

    @staticmethod
    def betweenOV(_: "Orient", __2: "XYZ", amount: float) -> ExtValue[None]:
        """
        interpolate orientation

        Like between2(), but the second Orient is composed of the supplied XYZ vector (X component) and Y Z vectors from the calling object.
        Example:
        var o=Orient.new();
        o.betweenOV(o,(0,1,0),1); //no change, o remains 100 010 001
        o.betweenOV(o,(0,1,0),0.9); //o is slightly rotated towards (0,1,0)
        o.betweenOV(o,(0,1,0),0); //o is completely transformed, o.x=(0,1,0)
        """
        ...

    @staticmethod
    def localToWorld(point: "XYZ", center: "XYZ") -> ExtValue:  # returns XYZ
        "transform coordinates"
        ...

    @staticmethod
    def worldToLocal(point: "XYZ", center: "XYZ") -> ExtValue:  # returns XYZ
        "transform coordinates"
        ...

    angles: ExtValue  # XYZ
    "Euler angles representation"
    toString: ExtValue[str]
    "textual form"


class Part(ExtValue):
    x: ExtValue[float]
    "position.x"
    y: ExtValue[float]
    "position.y"
    z: ExtValue[float]
    "position.z"
    sh: ExtValue[int]
    "shape"
    s: ExtValue[float]
    "size"
    sx: ExtValue[float]
    "scale.x"
    sy: ExtValue[float]
    "scale.y"
    sz: ExtValue[float]
    "scale.z"
    h: ExtValue[float]
    "hollow"
    dn: ExtValue[float]
    "density"
    fr: ExtValue[float]
    "friction"
    ing: ExtValue[float]
    "ingestion"
    as_: ExtValue[float]
    "assimilation"
    rx: ExtValue[float]
    "rot.x"
    ry: ExtValue[float]
    "rot.y"
    rz: ExtValue[float]
    "rot.z"
    i: ExtValue[str]
    "info"
    Vstyle: ExtValue[str]
    """
    Visual style
    
    See the "Visual style definition" context for more information
    """
    vr: ExtValue[float]
    "red component"
    vg: ExtValue[float]
    "green component"
    vb: ExtValue[float]
    "blue component"


class Population(ExtValue):
    """
    A set of Creature objects, sharing some high level simulation properties (performance calculation, NN simulation, collision detection, event handling). The groups usually have different roles in the experiment (e.g. Creatures groups and Food group in standard.expdef).
    You can iterate directly over Creatures in a Population using for(...in...) loops:
        for(var c in Populations[0]) Simulator.print(c.name);
    """

    index: ExtValue[int]
    "population index"
    name: ExtValue[str]
    "Group name"
    size: ExtValue[int]
    "Number of creatures"
    energy: ExtValue[int]
    """
    Energy calculation
    
    If turned off, creature's energy will be constant.
    """
    death: ExtValue[int]
    "Do creatures die when no energy?"
    nnsim: ExtValue[int]
    """
    Neural net simulation
    
    Replaced by initial_nn_active
    """
    initial_nn_active: ExtValue[int]
    """
    Neural net simulation
    
    Stabilization means no significant movement during a specified period of time. See http://www.framsticks.com/a/al_params.html#exper-perfcalc
    """
    nn_paused: ExtValue[int]
    """
    Neural net paused
    
    Disables NN simulation for all creatures in the population
    """
    perfperiod: ExtValue[int]
    """
    Performance sampling period
    
    Defines how often onUpdate() events are called and how often the built-in performance counters (distance, speed, etc.) are calculated. See http://www.framsticks.com/a/al_params.html#exper-perfcalc
    """
    stabilperiod: ExtValue[int]
    """
    Sampling period while waiting
    
    "Performance sampling period" for the stabilization phase.
    """
    killnostable: ExtValue[int]
    """
    Kill if no stabilization after
    
    Creatures that fail to stabilize after the specified waiting period (e.g. because they are continuously rolling) will be killed. 0 disables this feature.
    """
    stabledist: ExtValue[float]
    """
    Allowed distance to be stable
    
    A creature is considered stabilized when its center of gravity stays within the specified distance after the "Sampling period while waiting" has elapsed.
    """
    enableperf: ExtValue[int]
    """
    Performance calculation
    
    Replaced by initial_perf_measuring
    """
    initial_perf_measuring: ExtValue[int]
    """
    Performance calculation
    
    Stabilization means no significant movement during a specified period of time. See http://www.framsticks.com/a/al_params.html#exper-perfcalc
    """
    colmask: ExtValue[int]
    """
    Collision mask
    
    You should use selfmask and othermask instead of colmask (these masks are also much easier to understand than the old colmask field).
    """
    selfmask: ExtValue[int]
    """
    Collision mask (self)
    
    Collisions between objects can be handled in two ways:
     - standard 'mechanical' collision handler (simple 'rebound' effect)
     - special script handler (On[GROUPNAME]Collision function)
    
    In the script handler function, use the Collision object to access the two colliding parts of two creatures.
    The first part in the Collision object (i.e. Collision.Creature1) always concerns the creature that belongs to [GROUPNAME].
    The handler is called once for each creature that collides with the creature from [GROUPNAME].
    
    Collision masks that you set determine which handler will be used (none and both are also possible). On each collision, selfmask and othermask of the colliding objects are logically ANDed.
    If the resulting non-zero value falls into 16 lower bits (0x0000ffff), the standard handler is enabled.
    If the resulting non-zero value falls into 16 higher bits (0xffff0000), the custom handler is enabled.
    
    Examples:
    
    1.With one group, all possible combinations of the collision handlers are as follows:
    	- ignore collisions (e.g. selfmask=othermask=0)
    	- use standard handling (e.g. selfmask=othermask=1)
    	- use custom handling (e.g. selfmask=othermask=0x10000)
    	- use standard and custom handling (e.g. selfmask=othermask=0x10001)
    
    2.Two groups yield more interesting cases. Let us consider the 'standard.expdef' setting:
    	Creatures: selfmask=0x10001, othermask=0x20001
    	Food: selfmask=0x20002, othermask=0x10002
    There are three possible scenarios:
    	- creature and creature: collision value = 0x10001 & 0x20001 = 1 -> Standard handling will be used (1 is one of the lower 16 bits)
    	- food and food: collision value = 0x20002 & 0x10002 = 2 -> As above.
    	- creature and food: collision value = (0x10001 & 0x10002) or (0x20002 & 0x20001) = 0x10000 or 0x20000 -> Custom handling will be used (the result falls into higher 16 bits).
    
    
    Instead of manually calculating mask values, you can use this interactive graphical helper: http://www.framsticks.com/files/apps/js/population-mask-helper/index.html
    """
    othermask: ExtValue[int]
    """
    Collision mask (other)
    
    See selfmask.
    """
    bodysim: ExtValue[int]
    """
    Body simulation
    
    Replaced by initial_physics_active
    """
    initial_physics_active: ExtValue[int]
    """
    Body simulation
    
    Enable/disable physical body simulation. This is the initial value of Creature.physics_active for all objects created in this group. For details, see the documentation of Creature.physics_active.
    """
    selfcol: ExtValue[int]
    """
    Detect self-collisions
    
    Replaced by initial_self_collisions
    """
    initial_self_collisions: ExtValue[int]
    """
    Detect self-collisions
    
    Detect collisions within creature bodies (only applicable for the ODE simulation engine). This is the initial value of Creature.self_collisions for all objects created in this group. If enabled, creatures with self-colliding genotypes are not born, and others will have their sticks collide during lifespan.
    """
    em_stat: ExtValue[float]
    """
    Muscle static work
    
    Energy consumption of a muscle resisting an external force (whether performing or not performing any physical work). Framsticks muscles cannot be "turned off", but they can stop consuming "static" energy when the body part keeps itself in the requested position without stressing the muscle, e.g. when floating in the water or resting freely on the ground.
    """
    em_dyn: ExtValue[float]
    """
    Muscle dynamic work
    
    Energy consumption of a muscle moving a stick, calculated from the actual work performed by the muscle. Muscles must move to consume this kind of energy.
    """
    en_assim: ExtValue[float]
    """
    Assimilation productivity
    
    Maximal energy gain produced by a vertical specialized stick.
    Horizontal specialized sticks get half of this value.
    """

    @deprecated
    @staticmethod
    def createFromGenotype() -> ExtValue:  # returns Creature
        """
        Uses the selected Genotype object.
        Deprecated. Use the more universal add() function.
        """
        ...

    @deprecated
    @staticmethod
    def createFromString(genotype: str) -> ExtValue:  # returns Creature
        """
        Uses the supplied string argument.
        Deprecated. Use the more universal add() function.
        """
        ...

    @deprecated
    @staticmethod
    def createFromGeno(_: "Geno") -> ExtValue:  # returns Creature
        """
        Uses the supplied Geno object.
        Deprecated. Use the more universal add() function.
        """
        ...

    @staticmethod
    def add(Genotype_object_or_Geno_object_or_string_genotype_or_CreatureSnapshot_object: Any) -> ExtValue:  # returns Creature
        """
        Adding CreatureSnapshot object automatically copies the CreatureSnapshot fields into the Creature, including creature location (the center of the bounding box is preserved) and orientation.
        See also: CreatureSnapshot
        """
        ...

    @staticmethod
    def canAdd(
        Genotype_object_or_Geno_object_or_string_genotype_or_CreatureSnapshot_object: Any,
        treat_warnings_as_errors: int,
        mute: int,
    ) -> ExtValue[int]:
        """
        Check if the creature could be built from the supplied argument, as if add() was called - this is equivalent to add()ing a creature and immediately removing it, but without the side effects of onBorn().
        The mandatory second argument means: -1=obey the current simulator setting for "Don't simulate genotypes with warnings", 0=warnings during creature building are acceptable, 1=treat such warnings as a build failure (cannot add).
        Errors/warnings are emitted like in add(), unless mute=1.
        """
        ...

    @staticmethod
    def findUID(uid: str) -> ExtValue[int]:
        "Find a Creature by UID"
        ...

    @staticmethod
    def get(index: int) -> ExtValue:  # returns Creature
        "get creature object"
        ...

    @staticmethod
    def senseCreaturesProperty(x: float, y: float, z: float, propertyname: str, exclude: "Creature") -> ExtValue[float]:
        """
        Arguments:
         - x,y,z (sensor position)
         - property (name, data[key] or Class:id). "data[key]" can be used to access Creature's data field (Dictionary) containing named items
         - exclude (creature object)

        This function works like a smell sensor (but you can provide any property as the argument, not just "energy") for all creatures in this group except "exclude".
        The following is a sample function that reproduces the "S" sensor which smells creatures from all populations:
                function smellEnergyAllPopulations(x, y, z, exclude)
                {
                        var s=0;
                        for(var i=0; i<Populations.size; i++)
                                s += Populations[i].senseCreaturesProperty(x, y, z, "energy", exclude);
                        return s;
                }
        """
        ...

    @staticmethod
    def findCreatureAt(point: "Vector", vector: "Vector") -> ExtValue:  # returns Creature
        """
        Find creature

        Returns the first Creature object colliding with the line defined by the supplied starting point and the vector. For the purpose of this function, "collision" means "passing closer than 1.0 from any of the Creature's Parts".
        Note that a screen point corresponds to a 3D line going through the screen surface; if you want to identify the object under the mouse cursor, you can use this function because finding an object at a given screen coordinates can be a special case of finding the line-with-object collision.
        """
        ...

    @staticmethod
    def delete(Creature_object_or_index: Any) -> ExtValue[None]:
        "Delete the creature (remove it without executing the onKill event). Removing creatures inside some event handlers (e.g. onCollision) might be unsafe."
        ...

    @staticmethod
    def kill(Creature_object_or_index: Any) -> ExtValue[None]:
        "Kill the creature (remove it and execute its onKill handler). Killing creatures inside some event handlers (e.g. onCollision) might be unsafe. The recommended and safe way of killing a creature is by setting its energy to 0."
        ...

    @staticmethod
    def clear() -> ExtValue[None]:
        "Delete all creatures"
        ...

    iterator: ExtValue  # Object

    @staticmethod
    def getStatsMin(field_name: str) -> ExtValue[float]:
        """
        get stats minimum

        Retrieves data from stats.* object. Can only be used for fields covered by stats.* (subset of Creature fields).
        """
        ...

    @staticmethod
    def getStatsAvg(field_name: str) -> ExtValue[float]:
        """
        get stats average

        Retrieves data from stats.* object. Can only be used for fields covered by stats.* (subset of Creature fields).
        """
        ...

    @staticmethod
    def getStatsMax(field_name: str) -> ExtValue[float]:
        """
        get stats maximum

        Retrieves data from stats.* object. Can only be used for fields covered by stats.* (subset of Creature fields).
        """
        ...

    @staticmethod
    def refreshGUI() -> ExtValue[None]:
        """
        Refresh GUI

        Notify list content changed
        """
        ...


class Populations(ExtValue):
    """
    Manages all Creature objects in the experiment, organized in one or more groups.
    You can iterate directly over Population objects in the Populations collection using for(...in...) loops:
        for(var pop in Populations) Simulator.print(pop.name);

    Before version 4.0rc4 some operations could only be performed on the "selected" creature (the one pointed to by group/creature fields in Populations). Currently, the more convenient and recommended way is to call Creatures's functions that operate directly on the passed objects.

    The old way:
        Populations.group=0;
        Populations.creature=0;
        GenePools.getFromCreature();
        GenePools.copyTo(0);

    Doing the same the new way:
        Genotype.newFromCreature(Populations[0][0]).moveTo(GenePools[0]);

    See also: Creature, Population.
    """

    group: ExtValue[int]
    """
    selected group
    
    Index of the currently selected group (Population).
    Deprecated. Pass creature object to functions needing it, instead of the old "first select, then call" approach.
    """
    size: ExtValue[int]
    "Number of groups"
    creature: ExtValue[int]
    """
    selected creature
    
    Deprecated. Pass creature object to functions needing it, instead of the old "first select, then call" approach.
    """

    @deprecated
    @staticmethod
    def createFromGenotype() -> ExtValue:  # returns Creature
        "Uses the selected Genotype object."
        ...

    @deprecated
    @staticmethod
    def createFromString(genotype: str) -> ExtValue:  # returns Creature
        "Uses the supplied string argument."
        ...

    @deprecated
    @staticmethod
    def killSelected() -> ExtValue[None]:
        "Applies to the selected Creature."
        ...

    @deprecated
    @staticmethod
    def deleteSelected() -> ExtValue[None]:
        "Applies to the selected Creature."
        ...

    @staticmethod
    def addGroup(name: str) -> ExtValue:  # returns Population
        "Adds a new population."
        ...

    @staticmethod
    def deleteGroup(index: int) -> ExtValue[None]:
        "Removes a population."
        ...

    @staticmethod
    def clear() -> ExtValue[None]:
        "Removes all populations except the first one."
        ...

    @deprecated
    @staticmethod
    def clearGroup(index: int) -> ExtValue[None]:
        """
        Deprecated.
        Use Populations[pop_index].clear() instead of Populations.clearGroup(pop_index);
        """
        ...

    @deprecated
    @staticmethod
    def creatBBCollisions(mask: int) -> ExtValue[int]:
        """
        Checks approximate collisions for the selected creature.
        Returns the collision mask calculated as ( creature.selfmask & other_creatures.othermask ).
        Passing non-zero argument is equivalent to setting a temporary selfmask for the current creature.

        Deprecated. Use Creature.boundingBoxCollisions()
        """
        ...

    @staticmethod
    def get(index: int) -> ExtValue:  # returns Population
        ...

    @staticmethod
    def findCreatureAt(point: "Vector", vector: "Vector") -> ExtValue:  # returns Creature
        """
        Find creature

        Returns the first Creature object colliding with the line defined by the supplied starting point and the vector. For the purpose of this function, "collision" means "passing closer than 1.0 from any of the Creature's Parts".
        Note that a screen point corresponds to a 3D line going through the screen surface; if you want to identify the object under the mouse cursor, you can use this function because finding an object at a given screen coordinates can be a special case of finding the line-with-object collision.
        """
        ...

    iterator: ExtValue  # Object


class POVExport(ExtValue):
    povex_outdir: ExtValue[str]
    """
    Output directory
    
    Directory name WITHOUT trailing '/' sign
    """
    povex_outfiles: ExtValue[str]
    """
    Output files pattern
    
    Frame number replaces %d (eg. 'scene%03d.pov')
    """
    povex_skip: ExtValue[int]
    """
    Skip frames
    
    A scene file is generated each (n+1) simulation steps
    (a small value means more frames and smooth animation)
    """
    povex_startf: ExtValue[int]
    """
    Starting frame#
    
    Starting number
    """
    povex_maxframes: ExtValue[int]
    """
    Maximum frames
    
    How many frames are to be generated?
    """
    povex_dust: ExtValue[int]
    "Dust particles"
    povex_energy: ExtValue[int]
    "Energy particles"

    @staticmethod
    def povex_enable():  # returns Creature
        "Enable export"
        ...

    @staticmethod
    def povex_disable():  # returns Creature
        "Disable export"
        ...

    @staticmethod
    def povex_now():  # returns Creature
        "Export current scene"
        ...

    povex_currframe: ExtValue[int]
    "Next frame#"
    povex_enabled: ExtValue[int]
    "Export enabled"
    povex_lastfile: ExtValue[str]
    "Last filename"


class Ref(ExtValue):
    """
    Reference objects. Useful for returning things from functions.

    Example:
    var x=111;
    square(&x);// '&' creates the Reference object
    Simulator.print(x);//x is now 12321

    function square(r)
    {r.value=r.value*r.value;}
    //square receives the Reference object and changes its 'value' field
    """

    value: ExtValue  # untyped

    @staticmethod
    def newO():  # returns Creature
        """
        create new reference

        (for internal use only) use &variablename to create Ref objects.
        """
        ...

    @staticmethod
    def copyFrom(_: "Ref") -> ExtValue[None]:
        """
        copy the reference

        make the reference point to the same target,
        """
        ...

    toString: ExtValue[str]
    "textual form"


class Signal(ExtValue):
    """
    Signals broadcast information in a channel (being an abstract communication medium that could be imagined as sound, smell, vision or anything else). There are no sender-receiver associations, although the receiving party can filter out signals (two standard filtering methods are: physical neighborhood and one-dimensional attribute called flavor). Signals attached to neurons and creatures (created in Creature.signals and Neuro.signals) automatically follow the owner's location. Environmental signals (in World.signals) are stationary.

    Receiving:
    There are 2 kinds of data you can receive:
    1. aggregating functions (receive and receiveFilter) calculate the overall power of the received signal (based on the distance and the source power).
    2. receiveSet and receiveSingle fetch the individual Signal object(s) so it is possible to transmit something else than just a single number (by using Signal.value) and do more sophisticated processing.

    Creating: Use "add" in Creature.signals, Neuro.signals, or World.signals.
    """

    value: ExtValue  # untyped
    "Signal value can be any type. On the receiver side it is only available by accessing the individual Signal objects, i.e. after calling receiveSet() or receiveSingle(). The aggregating functions receive() and receiveFilter() ignore this attribute."
    power: ExtValue[float]
    "Signal power affects the aggregated signal value returned from receive() and receiveFilter()."
    flavor: ExtValue[float]
    "Signal flavor can be used to differentiate between signals in a single channel."
    channel: ExtValue[str]
    """
    Channel name
    
    Channel name, read-only.
    """
    pos: ExtValue  # XYZ
    """
    Position
    
    Signal position, read-only.
    """

    @staticmethod
    def remove():
        "Deletes the signal."
        ...


class SignalView(ExtValue):
    "This object can be used by an Experiment Definition or a Framsticks Theater show script to configure the preferred Signal visualization in the experiment. SignalView.mode and SignalView.label can also be adjusted in the Framsticks GUI (overriding the script-configured state)."

    @staticmethod
    def clear():
        """
        Clear 'Custom' mode settings

        Removes custom display settings that might have been defined by various scripts (expdef or show).
        """
        ...

    mode: ExtValue[int]
    '"Automatic" labels all signal sources in all channels and shows the intensity map of the first channel. This is sufficient for many simple setups, but as the number of signals and channels grows, the display becomes cluttered. In such cases, the experiment definition can define "Custom" signal visualization tailored for the particular experiment.'
    labels: ExtValue[str]
    """
    The label formula should return text to be displayed over the signal source, presumably by reading some values from the supplied Signal object. It is especially useful for more sophisticated signal usage scenarios, when Signal.value keeps a reference to an object (the default signal label only shows <XXX Object at xxxxx> in such cases).
    
    Examples: (switch to "Automatic" mode to see labels, then remove the label formula and compare the effect)
    
    return "x";
    return "val="+Signal.value;
    return "power="+Signal.power;
    """

    @staticmethod
    def addMap(channel: str, color: int) -> ExtValue[None]:
        "add channel"
        ...

    @staticmethod
    def addSignals(channel: str, color: int, angle_x: int, angle_y: int, angle_z: int) -> ExtValue[None]:
        "add channel"
        ...

    @staticmethod
    def addSignalsFilter(
        channel: str, color: int, angle_x: int, angle_y: int, angle_z: int, flavor: int, filter: int
    ) -> ExtValue[None]:
        "add channel"
        ...


class sim_params(ExtValue):
    "This object groups all simulator parameters so they can be loaded or saved with a single call (see scripts/standard_loadsave.inc). For other purposes please use specific objects, like Simulator, World, Populations, etc."

    @staticmethod
    def print(text: str) -> ExtValue[None]:
        """
        Print information message

        One argument: message to be printed.
        """
        ...

    @staticmethod
    def message(text: str, level: int) -> ExtValue[None]:
        """
        Print message

        The second argument can be:
         -1 = debugging message
         0 = information
         1 = warning
         2 = error
         3 = critical error
        """
        ...

    @staticmethod
    def sleep(milliseconds: int) -> ExtValue[None]:
        "Suspends the execution for a specified interval."
        ...

    @staticmethod
    def beep() -> ExtValue[None]:
        "Plays the default system sound."
        ...

    @staticmethod
    def sound(freqency_in_Hz: int, length_in_milliseconds: int) -> ExtValue[None]:
        "Generates a simple tone on the speaker"
        ...

    @staticmethod
    def eval(script_statement: str) -> ExtValue[None]:
        """
        Evaluate a statement

        The argument must be a complete statement, e.g. "return 2+2;" is valid, while "2+2" is not. The Error object is returned for invalid statements.
        Example:
        var statement="function fun(a) {return a*a;} return fun(Math.pi);";
        var result=Simulator.eval(statement);
        if (typeof result=="Error")
           Simulator.print("Error:"+result.message);
        else
           Simulator.print("Result:"+result);
        """
        ...

    @staticmethod
    def load(filename: str) -> ExtValue[None]:
        'Load experiment file (calls onExpLoad() in the current experiment definition). This function is intended to replace the simulator state; the old state is cleared by automatically calling "resetToDefaults()". Use "import" if you don\'t want to lose the old simulator state. Contents can also be loaded from string by using specifically formed filename: "string://string_contents_to_be_loaded".'
        ...

    @overload
    @staticmethod
    def import_(filename: str, options: int) -> ExtValue[None]:
        """
        Import some data from file. Contents can also be imported from string by using specifically formed filename: "string://string_contents_to_be_imported".
        The second optional argument selects what section(s) will be imported:
                1 - experiment (works just like load(), all other bits are ignored, and can reset the simulator state!)
                2 - genotypes
                4 - simulator parameters
                8 - genepool settings
                16 - population settings
                32 - new groups will be created for imported genepools and populations
                64 - allow switching to a different expdef while importing parameters (4)
                256 - creatures

        The standard behavior (without the second argument) is to import genotypes, parameters, and genepool and population settings (2+4+8+16). Note that "64" is not included by default, because the expdef change resets all simulator parameters, which contradicts the usual meaning of "import" in Framsticks ("add data", as opposed to "load" meaning "replace data"). Moreover, using the "64" option in scripts can be dangerous, especially all expdef and show scripts should always declare the proper expdef name in their header rather than change the expdef directly. Without the "64" option, it is always safe to "import" any file in a script regardless of the current simulator state.
        """
        ...

    @overload
    @staticmethod
    def import_(filename: str) -> ExtValue[None]:
        "Equivalent to import(filename,2+4+8+16) - imports genotypes, parameters, genepool and population settings."
        ...

    @staticmethod
    def save(filename: str) -> ExtValue:  # returns untyped
        "Save experiment file (calls onExpSave() in the current experiment definition). Providing null filename makes save() return saved data as a text string instead of writing it to the file."
        ...

    @staticmethod
    def export(filename: str, options: int, genepool: int, population: int) -> ExtValue:  # returns untyped
        """
        Save some data to file. Arguments:
        - filename: can be null, which makes export() return saved data as a text string instead of writing it to the file.
        - options: composed of the following bit values:
                1 - experiment (works just like save() and all other option bits are ignored)
                2 - genotypes
                4 - simulator parameters
                8 - simulator stats
                16 - genepool settings
                32 - population settings
                64 - do autosave
                256 - creatures
        - selected genepool, -1 means all genepools
        - selected population, -1 means all populations
        """
        ...

    @staticmethod
    def start() -> ExtValue[None]:
        """
        Start simulation

        Called by the user interface.
        """
        ...

    @staticmethod
    def stop() -> ExtValue[None]:
        """
        Stop simulation

        The expdef script calls this function to stop simulation.
        """
        ...

    running: ExtValue[int]
    """
    Is the simulation running?
    
    Useful for synchronizing the user interface state.
    """
    stop_on: ExtValue[int]
    """
    Error level to stop running simulation
    
    If the simulation is running and a message is emitted with at least the selected severity, the simulation will be stopped.
    """

    @staticmethod
    def step() -> ExtValue[None]:
        "Do a single simulation step"
        ...

    time: ExtValue[int]
    """
    Number of steps
    
    Simulator.time will be removed because of its misleading name, please use Simulator.stepNumber instead.
    """
    last_genotype_num: ExtValue[int]
    """
    Largest previously used Genotype.num
    
    See: Genotype.num
    """
    last_creature_num: ExtValue[int]
    """
    Largest previously used Creature.num
    
    See: Creature.num
    """
    stepNumber: ExtValue[int]
    "Number of simulation steps"
    simspeed: ExtValue[int]
    """
    Simulation speed
    
    steps/second
    """
    expdef: ExtValue[str]
    """
    Experiment definition
    
    Choose the experiment framework
    (in Windows GUI, confirm by pressing 'Apply')
    
    Stop the simulation before selecting another experiment definition.
    It is a good practice to initialize the experiment before running the simulation.
    """
    expdef_title: ExtValue[str]
    "Title"
    expdef_info: ExtValue[str]
    "Description"

    @staticmethod
    def init() -> ExtValue[None]:
        """
        Initialize experiment

        Prepares the experiment for running - usually performs initialization procedures such as resetting counters, states, gene pools, etc.
        These actions are defined in the onInit() function of this experiment definition.
        """
        ...

    @staticmethod
    def loadexpdef() -> ExtValue[None]:
        """
        Reload experiment definition

        Resets the simulator to its default state, resets all parameters to default values and then loads this experiment definition.
        """
        ...

    usercode: ExtValue[str]
    """
    Script override
    
    You can override any function from the original experiment definition script. Use the same function names and provide alternative implementations.
    Example:
    
    function onBorn(cr)
    {
      Simulator.print("A creature is born: "+cr.name);
      super_onBorn(cr); //calls the original implementation
    }
    """
    autosaveperiod: ExtValue[int]
    """
    Save backup
    
    Save simulation state once every n-th event
    (events are defined by the script. For 'standard.expdef' it is after each death).
    Save EXPT file first to initialize name for autosave files.
    Slave simulators (in multithreaded experiments) ignore this setting and never create autosave files.
    """
    overwrite: ExtValue[int]
    """
    Overwrite files?
    
    Lets you choose what to do when a file is created with the same name as an already existing file: overwite the existing file or create its backup?
    """
    filecomm: ExtValue[int]
    """
    Show file comments
    
    Controls displaying comments encountered in opened files.
    """

    @staticmethod
    def checkpoint() -> ExtValue[None]:
        """
        Notify that the experiment state was significantly updated.

        This function was previously called "autosave".
        """
        ...

    @staticmethod
    def checkpointData(any_data: Any) -> ExtValue[None]:
        """
        Notify that the experiment state was significantly updated + pass data.

        In the distributed/paralellized scenario the data passed as argument can be received by the controlling entity (onSlaveCheckpoint in multithreaded master experiment, /simulator/expevent in distributed network simulator).
        """
        ...

    lastCheckpoint: ExtValue  # untyped
    """
    Last checkpoint
    
    Most recently reported by the experiment definition script.
    """

    @staticmethod
    def resetToDefaults() -> ExtValue[None]:
        """
        Reset the simulator state

        Clears groups and loads default values for simulator parameters, then calls onExpDefLoad() of the current experiment definition.
        """
        ...

    createrr: ExtValue[int]
    "Object creation errors"
    groupchk: ExtValue[int]
    """
    Warn on adding invalid genotypes
    
    Warnings will be printed when invalid genotypes are added to a gene pool.
    """
    creatwarnfail: ExtValue[int]
    """
    Don't simulate genotypes with warnings
    
    Creatures grown with warnings will not be simulated. This helps prevent the propagation of faulty genes, because genotypes that cause warnings when interpreted will not reproduce.
    """
    vmdebug: ExtValue[int]
    "VM debug"
    vm_step_limit: ExtValue[int]
    """
    VM step limit
    
    Abort any script (expdef, fitness formula, user script) when it performs too many operations - which can take more or less time depending on your machine performance. This can protect against infinite loops or unbearably long runs of untested scripts that would otherwise force you to kill the whole application. Use Simulator.vm_..._warning if you only need information about what script takes too much time without aborting it.
    """
    vm_step_warning: ExtValue[int]
    """
    VM step warning
    
    Display a warning when any script (expdef, fitness formula, user script) performs too many operations - which can take more or less time depending on your machine performance. Use Simulator.vm_..._limit to prevent the application from becoming unresponsive by aborting misbehaving scripts.
    """
    vm_time_limit: ExtValue[float]
    """
    VM time limit
    
    Abort any script (expdef, fitness formula, user script) when it takes too much time - measured in seconds. The actual amount of work depends on your machine performance. This can protect against infinite loops or unbearably long runs of untested scripts that would otherwise force you to kill the whole application. Use Simulator.vm_..._warning if you only need information about what script takes too much time without aborting it.
    """
    vm_time_warning: ExtValue[float]
    """
    VM time warning
    
    Display a warning when any script (expdef, fitness formula, user script) takes too much time - measured in seconds. The actual amount of work depends on your machine performance. Use Simulator.vm_..._limit to prevent the application from becoming unresponsive by aborting misbehaving scripts.
    """

    @staticmethod
    def new() -> ExtValue:  # returns Simulator
        "create new Simulator"
        ...

    slaves: ExtValue  # SlaveSimulators
    "Slave simulator objects"
    cpus: ExtValue[int]
    "Number of detected CPUs ('cores') on this machine"
    world: ExtValue  # World
    populations: ExtValue  # Populations
    genepools: ExtValue  # GenePools
    "Gene pools object"
    expproperties: ExtValue  # ExpProperties
    expstate: ExtValue  # ExpState
    genman: ExtValue  # GenMan
    genoconverters: ExtValue  # GenoConverters
    "Genotype converters object"

    @staticmethod
    def reloadNeurons() -> ExtValue[None]:
        "Reload neuron definitions"
        ...

    userdata: ExtValue  # untyped
    "User field"
    identity: ExtValue[int]
    "-1 for master simulator, 0...count-1 for slaves"

    @staticmethod
    def refreshGUI() -> ExtValue[None]:
        """
        Refresh GUI

        Notify that all populations and gene pools content changed.
        """
        ...

    version_string: ExtValue[str]
    """
    Version string
    
    Current application version as a string (human-friendly).
    """
    version_int: ExtValue[int]
    """
    Version integer
    
    Current application version as an integer.
    """

    @staticmethod
    def _propertyClear() -> ExtValue[None]:
        """
        Remove all properties

        Using most _property functions is restricted for internal purposes. Use "property:" or "state:" definitions in your script files to change object properties.
        """
        ...

    @staticmethod
    def _propertyAdd(id: str, type_description: str, name: str, flags: int, help_text: str) -> ExtValue[None]:
        """
        Add property (id,type,name,help)

        Using most _property functions is restricted for internal purposes. Use "property:" or "state:" definitions in your script files to change object properties.
        """
        ...

    @staticmethod
    def _propertyRemove(index: int) -> ExtValue[None]:
        """
        Remove property

        Using most _property functions is restricted for internal purposes. Use "property:" or "state:" definitions in your script files to change object properties.
        """
        ...

    @staticmethod
    def _propertyChange(id: str, type_description: str, name: str, flags: int, help_text: str) -> ExtValue[None]:
        """
        Change property

        Using most _property functions is restricted for internal purposes. Use "property:" or "state:" definitions in your script files to change object properties.
        """
        ...

    @staticmethod
    def _propertyAddGroup(name: str) -> ExtValue[None]:
        """
        Add property group

        Using most _property functions is restricted for internal purposes. Use "property:" or "state:" definitions in your script files to change object properties.
        """
        ...

    @staticmethod
    def _propertyRemoveGroup(index: int) -> ExtValue[None]:
        """
        Remove property group

        Using most _property functions is restricted for internal purposes. Use "property:" or "state:" definitions in your script files to change object properties.
        """
        ...

    @staticmethod
    def _propertyExists(name: str) -> ExtValue[int]:
        "Check for property existence"
        ...

    _property_changed_index: ExtValue[int]
    "Last changed property index"
    _property_changed_id: ExtValue[str]
    "Last changed property id"
    wrldtyp: ExtValue[int]
    "Type"
    wrldsiz: ExtValue[float]
    """
    Size
    
    Side length of the world
    """
    wrldmap: ExtValue[str]
    """
    Map
    
    Description of the world (only applies to world types: "Blocks" or "Heightfield").
    To generate a random landscape, use:
       r[scaling] <sizex> <sizey> [seed]
    To generate a custom landscape, provide height values:
       m[scaling] <sizex> <sizey> digits...
     or
       M[scaling] <sizex> <sizey> numbers...
    
    "digits..." is a sequence of integer values 0,1,2,..,9. You may also use '-' and '|' characters for smooth slides between blocks.
    "numbers..." is a sequence of floating point values, so the "M" option provides more freedom.
    [scaling] is an optional linear scaling expression in the form of *FACTOR+OFFSET or *FACTOR-OFFSET, for example "r*0.1-2 5 5" creates a 5x5 random map with a 10% amplitude, shifted down by 2.
    
    See also the WorldMap object.
    """
    wrldwat: ExtValue[float]
    "Water level"
    wrldbnd: ExtValue[int]
    """
    Boundaries
    
    Teleporting a creature that is outside of the world area is attempted every 'performance sampling period' steps. Teleport succeeds only when the target location in the world is empty (there is no collision).
    """
    wrldg: ExtValue[float]
    """
    Gravity
    
    You can adjust gravity for your experiments.
    The "official" setting used to evaluate and compare creatures is 1.
    """

    @staticmethod
    def wrldchg() -> ExtValue[None]:
        "Trigger world update"
        ...

    simtype: ExtValue[int]
    """
    Simulation engine
    
    MechaStick is a fast and simple primary Framsticks simulation engine.
    ODE is Open Dynamics Engine by Russel Smith et al.
    
    NOTE: switching between simulation engines causes removal of all objects in the world (e.g. creatures).
    """
    nnspeed: ExtValue[float]
    """
    NN speed
    
    Number of neural network simulation steps in each physics simulation step
    """
    rndcollisions: ExtValue[int]
    """
    Random collision order
    
    When enabled, custom collision handlers are invoked in random order. This can help remove unfair bias in some experiments - for example where the same collision order in each simulation step would cause some creatures colliding with food to consume energy while other colliding creatures would starve.
    """
    signals: ExtValue  # WorldSignals
    "Signal sources"
    odeshape: ExtValue[int]
    "Stick shape for ball-and-stick models"
    odestep: ExtValue[float]
    "Simulation step"
    odemusclemin: ExtValue[float]
    """
    Muscle min power
    
    i.e. "mmmmm" in f1
    """
    odemusclemax: ExtValue[float]
    """
    Muscle max power
    
    i.e. "MMMMM" if f1
    """
    odemusclespeed: ExtValue[float]
    """
    Muscle speed limit
    
    Muscle state cannot change faster than the supplied value
    """
    odeairdrag: ExtValue[float]
    """
    Drag
    
    A drag force ("air drag") proportional to the velocity of mass centers of moving parts (ODE's "linear damping")
    """
    oderotdrag: ExtValue[float]
    """
    Rotation drag
    
    Drag momentum acting on rotating bodies (ODE's "angular damping")
    """
    odewaterdrag: ExtValue[float]
    "Water drag"
    odewaterbuoy: ExtValue[float]
    "Water buoyancy"
    odeseed: ExtValue[int]
    """
    Randomness
    
    Affects collisions.
    - 'Truly random' is closest to the standard ODE operation. Use Math.seed to influence randomness in ODE collisions.
    - 'Deterministic' automatically calculates random seed in each step based on the current simulation (world) state, which makes the simulation repeatable but more random than 'Fixed'.
    - 'Fixed' is completely deterministic and does not depend on Math.seed - the same seed value is set before each step. This might negatively affect ODE accuracy.
    """
    odesepsticks: ExtValue[int]
    """
    Separate sticks
    
    Each stick gets a separate ODE body (like in MechaStick)
    """
    odeworlderp: ExtValue[float]
    """
    ERP
    
    World ERP (error reduction parameter)
    """
    odeworldcfm: ExtValue[float]
    """
    CFM
    
    World CFM (constraint force mixing)
    """
    odecolmumin: ExtValue[float]
    """
    Min. friction
    
    Mu coefficient for Parts with minimal friction (i.e. "fffff" in f1)
    """
    odecolmumax: ExtValue[float]
    """
    Max. friction
    
    Mu coefficient for Parts with maximal friction (i.e. "FFFFF" in f1)
    """
    odecolbounce: ExtValue[float]
    "Bounce"
    odecolbouncevel: ExtValue[float]
    "Bounce velocity"
    odecolsoftcfm: ExtValue[float]
    "Soft CFM"
    odecolsofterp: ExtValue[float]
    "Soft ERP"
    odecol2mumin: ExtValue[float]
    """
    Min. friction
    
    Mu coefficient for Parts with minimal friction (i.e. "fffff" in f1)
    """
    odecol2mumax: ExtValue[float]
    """
    Max. friction
    
    Mu coefficient for Parts with maximal friction (i.e. "FFFFF" in f1)
    """
    odecol2bounce: ExtValue[float]
    "Bounce"
    odecol2bouncevel: ExtValue[float]
    "Bounce velocity"
    odecol2softcfm: ExtValue[float]
    "Soft CFM"
    odecol2softerp: ExtValue[float]
    "Soft ERP"

    @staticmethod
    def rayIntersection(
        position_x: float,
        position_y: float,
        position_z: float,
        direction_x: float,
        direction_y: float,
        direction_z: float,
        max_distance: float,
    ) -> ExtValue[float]:
        "ray intersection"
        ...

    gen_hist: ExtValue[int]
    """
    Remember history of genetic operations
    
    Required for phylogenetic analysis
    """
    gen_hilite: ExtValue[int]
    """
    Use syntax highlighting
    
    Use colors for genes?
    (slows down viewing/editing of huge genotypes)
    """
    gen_extmutinfo: ExtValue[int]
    """
    Extended mutation info
    
    If active, information about employed mutation method will be stored in the 'info' field of each mutated genotype.
    """

    @staticmethod
    def operReport() -> ExtValue[None]:
        """
        Operators report

        Show available genetic operators
        """
        ...

    @staticmethod
    def toHTML(_: str) -> ExtValue[str]:
        """
        HTMLize a genotype

        returns genotype expressed as colored HTML
        """
        ...

    @staticmethod
    def toHTMLshort(_: str) -> ExtValue[str]:
        """
        HTMLize a genotype, shorten if needed

        returns genotype (abbreviated if needed) in colored HTML format
        """
        ...

    @staticmethod
    def toLaTeX(_: str) -> ExtValue[str]:
        """
        LaTeXize a genotype

        returns genotype in colored LaTeX format
        """
        ...

    @staticmethod
    def validate(_: "Geno") -> ExtValue:  # returns Geno
        "returns validated (if possible) Geno object from supplied Geno"
        ...

    @staticmethod
    def mutate(_: "Geno") -> ExtValue:  # returns Geno
        "returns mutated Geno object from supplied Geno"
        ...

    @staticmethod
    def crossOver(_: "Geno", __2: "Geno") -> ExtValue:  # returns Geno
        "returns crossed over genotype"
        ...

    @staticmethod
    def getSimplest(format: str) -> ExtValue:  # returns Geno
        """
        Get simplest genotype

        returns the simplest genotype for a given encoding (format). "0" means f0, "4" means f4, etc.
        """
        ...

    genoper_f0: ExtValue[int]
    "Operators for f0"
    genoper_f0s: ExtValue[int]
    "Operators for f0s"
    genoper_f1: ExtValue[int]
    "Operators for f1"
    genoper_f4: ExtValue[int]
    "Operators for f4"
    genoper_f8: ExtValue[int]
    "Operators for f8"
    genoper_f9: ExtValue[int]
    "Operators for f9"
    genoper_fF: ExtValue[int]
    "Operators for fF"
    genoper_fn: ExtValue[int]
    "Operators for fn"
    genoper_fB: ExtValue[int]
    "Operators for fB"
    genoper_fH: ExtValue[int]
    "Operators for fH"
    genoper_fL: ExtValue[int]
    "Operators for fL"
    genoper_fS: ExtValue[int]
    "Operators for fS"
    neuadd_N: ExtValue[int]
    """
    Neuron (N)
    
    Standard neuron
    
    Characteristics:
       supports any number of inputs
       provides output value
       does not require location in body
    
    
    Properties:
       Inertia (in) float 0..1 (default 0.8)
       Force (fo) float 0..999 (default 0.04)
       Sigmoid (si) float -99999..99999 (default 2)
       State (s) float -1..1 (default 0)
    """
    neuadd_Nu: ExtValue[int]
    """
    Unipolar neuron [EXPERIMENTAL!] (Nu)
    
    Works like standard neuron (N) but the output value is scaled to 0...+1 instead of -1...+1.
    Having 0 as one of the saturation states should help in "gate circuits", where input signal is passed through or blocked depending on the other singal.
    
    Characteristics:
       supports any number of inputs
       provides output value
       does not require location in body
    
    
    Properties:
       Inertia (in) float 0..1 (default 0.8)
       Force (fo) float 0..999 (default 0.04)
       Sigmoid (si) float -99999..99999 (default 2)
       State (s) float -1..1 (default 0)
    """
    neuadd_G: ExtValue[int]
    """
    Gyroscope (G)
    
    Tilt sensor.
    Signal is proportional to sin(angle) = most sensitive in horizontal orientation.
    0=the stick is horizontal
    +1/-1=the stick is vertical
    
    Characteristics:
       does not use inputs
       provides output value
       should be located on a Joint
    """
    neuadd_Gpart: ExtValue[int]
    """
    Part Gyroscope (Gpart)
    
    Tilt sensor. Signal is directly proportional to the tilt angle.
    0=the part X axis is horizontal
    +1/-1=the axis is vertical
    
    Characteristics:
       does not use inputs
       provides output value
       should be located on a Part
    
    
    Properties:
       rotation.y (ry) float -6.282..6.282 (default 0)
       rotation.z (rz) float -6.282..6.282 (default 0)
    """
    neuadd_T: ExtValue[int]
    """
    Touch (T)
    
    Touch and proximity sensor (Tcontact and Tproximity combined)
    -1=no contact
    0=just touching
    >0=pressing, value depends on the force applied (not implemented in ODE mode)
    
    Characteristics:
       does not use inputs
       provides output value
       should be located on a Part
    
    
    Properties:
       Range (r) float 0..1 (default 1)
       rotation.y (ry) float -6.282..6.282 (default 0)
       rotation.z (rz) float -6.282..6.282 (default 0)
    """
    neuadd_Tcontact: ExtValue[int]
    """
    Touch contact (Tcontact)
    
    Touch sensor.
    -1=no contact
    0=the Part is touching the obstacle
    >0=pressing, value depends on the force applied (not implemented in ODE mode)
    
    Characteristics:
       does not use inputs
       provides output value
       should be located on a Part
    """
    neuadd_Tproximity: ExtValue[int]
    """
    Touch proximity (Tproximity)
    
    Proximity sensor detecting obstacles along the X axis.
    -1=distance is "r" or more
    0=zero distance
    
    Characteristics:
       does not use inputs
       provides output value
       should be located on a Part
    
    
    Properties:
       Range (r) float 0..1 (default 1)
       rotation.y (ry) float -6.282..6.282 (default 0)
       rotation.z (rz) float -6.282..6.282 (default 0)
    """
    neuadd_S: ExtValue[int]
    """
    Smell (S)
    
    Smell sensor. Aggregated "smell of energy" experienced from all energy objects (creatures and food pieces).
    Close objects have bigger influence than the distant ones: for each energy source, its partial feeling is proportional to its energy/(distance^2)
    
    Characteristics:
       does not use inputs
       provides output value
       should be located on a Part
    """
    neuadd_Constant: ExtValue[int]
    """
    Constant (*)
    
    Constant value
    
    Characteristics:
       does not use inputs
       provides output value
       does not require location in body
    """
    neuadd_Bend_muscle: ExtValue[int]
    """
    Bend muscle (|)
    
    Characteristics:
       uses single input
       does not provide output value
       should be located on a Joint
    
    
    Properties:
       power (p) float 0..1 (default 0.25)
       bending range (r) float 0..1 (default 1)
    """
    neuadd_Rotation_muscle: ExtValue[int]
    """
    Rotation muscle (@)
    
    Characteristics:
       uses single input
       does not provide output value
       should be located on a Joint
    
    
    Properties:
       power (p) float 0..1 (default 1)
    """
    neuadd_M: ExtValue[int]
    """
    Muscle for solids (M)
    
    Characteristics:
       uses single input
       does not provide output value
       should be located on a Joint
    
    
    Properties:
       power (p) float 0..1 (default 1)
       axis (a) integer 0..1 (default 0)
    """
    neuadd_D: ExtValue[int]
    """
    Differentiate (D)
    
    Calculate the difference between the current and previous input value. Multiple inputs are aggregated with respect to their weights
    
    Characteristics:
       supports any number of inputs
       provides output value
       does not require location in body
    """
    neuadd_Fuzzy: ExtValue[int]
    """
    Fuzzy system [EXPERIMENTAL!] (Fuzzy)
    
    Refer to publications to learn more about this neuron.
    
    Characteristics:
       supports any number of inputs
       provides output value
       does not require location in body
    
    
    Properties:
       number of fuzzy sets (ns) integer
       number of rules (nr) integer
       fuzzy sets (fs) string (default "")
       fuzzy rules (fr) string (default "")
    """
    neuadd_VEye: ExtValue[int]
    """
    Vector Eye [EXPERIMENTAL!] (VEye)
    
    Refer to publications to learn more about this neuron.
    
    Characteristics:
       uses single input
       provides output value
       should be located on a Part
    
    
    Properties:
       target.x (tx) float
       target.y (ty) float
       target.z (tz) float
       target shape (ts) string (default "")
       perspective (p) float 0.1..10 (default 1)
       scale (s) float 0.1..100 (default 1)
       show hidden lines (h) integer 0..1 (default 0)
       output lines count (each line needs four channels) (o) integer 0..99 (default 0)
       debug (d) integer 0..1 (default 0)
    """
    neuadd_VMotor: ExtValue[int]
    """
    Visual-Motor Cortex [EXPERIMENTAL!] (VMotor)
    
    Must be connected to the VEye and properly set up. Refer to publications to learn more about this neuron.
    
    Characteristics:
       supports any number of inputs
       provides output value
       does not require location in body
    
    
    Properties:
       number of basic features (noIF) integer
       number of degrees of freedom (noDim) integer
       parameters (params) string
    """
    neuadd_Sti: ExtValue[int]
    """
    Sticky [EXPERIMENTAL!] (Sti)
    
    Characteristics:
       uses single input
       does not provide output value
       should be located on a Part
    """
    neuadd_LMu: ExtValue[int]
    """
    Linear muscle [EXPERIMENTAL!] (LMu)
    
    Characteristics:
       uses single input
       does not provide output value
       should be located on a Joint
    
    
    Properties:
       power (p) float 0.01..1 (default 1)
    """
    neuadd_Water: ExtValue[int]
    """
    Water detector (Water)
    
    Output signal:
    0=on or above water surface
    1=under water (deeper than 1)
    0..1=in the transient area just below water surface
    
    Characteristics:
       does not use inputs
       provides output value
       should be located on a Part
    """
    neuadd_Energy: ExtValue[int]
    """
    Energy level (Energy)
    
    The current energy level divided by the initial energy level.
    Usually falls from initial 1.0 down to 0.0 and then the creature dies. It can rise above 1.0 if enough food is ingested
    
    Characteristics:
       does not use inputs
       provides output value
       does not require location in body
    """
    neuadd_Ch: ExtValue[int]
    """
    Channelize (Ch)
    
    Combines all input signals into a single multichannel output; Note: ChSel and ChMux are the only neurons which support multiple channels. Other neurons discard everything except the first channel.
    
    Characteristics:
       supports any number of inputs
       provides output value
       does not require location in body
    """
    neuadd_ChMux: ExtValue[int]
    """
    Channel multiplexer (ChMux)
    
    Outputs the selected channel from the second (multichannel) input. The first input is used as the selector value (-1=select first channel, .., 1=last channel)
    
    Characteristics:
       uses 2 inputs
       provides output value
       does not require location in body
    """
    neuadd_ChSel: ExtValue[int]
    """
    Channel selector (ChSel)
    
    Outputs a single channel (selected by the "ch" parameter) from multichannel input
    
    Characteristics:
       uses single input
       provides output value
       does not require location in body
    
    
    Properties:
       channel (ch) integer
    """
    neuadd_Rnd: ExtValue[int]
    """
    Random noise (Rnd)
    
    Generates random noise (subsequent random values in the range of -1..+1)
    
    Characteristics:
       does not use inputs
       provides output value
       does not require location in body
    """
    neuadd_Sin: ExtValue[int]
    """
    Sinus generator (Sin)
    
    Output frequency = f0+input
    
    Characteristics:
       uses single input
       provides output value
       does not require location in body
    
    
    Properties:
       base frequency (f0) float -1..1 (default 0.0628319)
       time (t) float 0..6.28319 (default 0)
    """
    f0_nodel_tag: ExtValue[int]
    """
    Respect the 'delete inhibit' tag
    
    You can tag elements using their 'i' field and the i="mi=d" tag.
    Mutations will not delete such elements.
    The i="mi=dm" combination is allowed.
    """
    f0_nomod_tag: ExtValue[int]
    """
    Respect the 'modify inhibit' tag
    
    You can tag elements using their 'i' field and the i="mi=m" tag.
    Mutations will not modify properties of such elements.
    The i="mi=md" combination is allowed.
    """
    f0_p_new: ExtValue[float]
    "New part"
    f0_p_del: ExtValue[float]
    "Delete part"
    f0_p_swp: ExtValue[float]
    "Swap parts"
    f0_p_pos: ExtValue[float]
    "Position"
    f0_p_den: ExtValue[float]
    """
    Density
    
    Density only has an influence under water
    """
    f0_p_frc: ExtValue[float]
    "Friction"
    f0_p_ing: ExtValue[float]
    "Ingestion"
    f0_p_asm: ExtValue[float]
    """
    Assimilation
    
    The interpretation and influence of this property must be implemented by the experiment definition
    """
    f0_p_color: ExtValue[float]
    """
    Visual only: color
    
    If this value is above zero, apart from this mutation occurring, the color of every newly created gray Part will be mutated on creation
    """
    f0_j_new: ExtValue[float]
    "New joint"
    f0_j_del: ExtValue[float]
    "Delete joint"
    f0_j_stm: ExtValue[float]
    """
    Stamina
    
    The interpretation and influence of this property must be implemented by the experiment definition
    """
    f0_j_stf: ExtValue[float]
    "Stiffness"
    f0_j_rsf: ExtValue[float]
    "Rotational stiffness"
    f0_j_color: ExtValue[float]
    """
    Visual only: color
    
    If this value is above zero, apart from this mutation occurring, every newly created Joint will be assigned a color that is the average color of both joined Parts
    """
    f0_n_new: ExtValue[float]
    "New neuron"
    f0_n_del: ExtValue[float]
    "Delete neuron"
    f0_n_prp: ExtValue[float]
    "Change properties"
    f0_c_new: ExtValue[float]
    "New connection"
    f0_c_del: ExtValue[float]
    "Delete connection"
    f0_c_wei: ExtValue[float]
    "Change weight"
    f0s_nodel_tag: ExtValue[int]
    """
    Respect the 'delete inhibit' tag
    
    You can tag elements using their 'i' field and the i="mi=d" tag.
    Mutations will not delete such elements.
    The i="mi=dm" combination is allowed.
    """
    f0s_nomod_tag: ExtValue[int]
    """
    Respect the 'modify inhibit' tag
    
    You can tag elements using their 'i' field and the i="mi=m" tag.
    Mutations will not modify properties of such elements.
    The i="mi=md" combination is allowed.
    """
    f0s_circle_section: ExtValue[int]
    """
    Ensure circle section
    
    Ensure that ellipsoids and cylinders have circle cross-section
    """
    f0s_use_elli: ExtValue[int]
    "Use ellipsoids in mutations"
    f0s_use_cub: ExtValue[int]
    "Use cuboids in mutations"
    f0s_use_cyl: ExtValue[int]
    "Use cylinders in mutations"
    f0s_p_new: ExtValue[float]
    "New part"
    f0s_p_del: ExtValue[float]
    "Delete part"
    f0s_p_swp: ExtValue[float]
    "Swap parts"
    f0s_p_pos: ExtValue[float]
    "Position"
    f0s_p_rot: ExtValue[float]
    "Rotation"
    f0s_p_scale: ExtValue[float]
    "Size (precisely, 'scale')"
    f0s_p_frc: ExtValue[float]
    "Friction"
    f0s_p_ing: ExtValue[float]
    "Ingestion"
    f0s_p_asm: ExtValue[float]
    """
    Assimilation
    
    The interpretation and influence of this property must be implemented by the experiment definition
    """
    f0s_p_color: ExtValue[float]
    """
    Visual only: color
    
    If this value is above zero, apart from this mutation occurring, the color of every newly created gray Part will be mutated on creation
    """
    f0s_j_new: ExtValue[float]
    "New joint"
    f0s_j_del: ExtValue[float]
    "Delete joint"
    f0s_j_stm: ExtValue[float]
    """
    Stamina
    
    The interpretation and influence of this property must be implemented by the experiment definition
    """
    f0s_j_color: ExtValue[float]
    """
    Visual only: color
    
    If this value is above zero, apart from this mutation occurring, every newly created Joint will be assigned a color that is the average color of both joined Parts
    """
    f0s_n_new: ExtValue[float]
    "New neuron"
    f0s_n_del: ExtValue[float]
    "Delete neuron"
    f0s_n_prp: ExtValue[float]
    "Change properties"
    f0s_c_new: ExtValue[float]
    "New connection"
    f0s_c_del: ExtValue[float]
    "Delete connection"
    f0s_c_wei: ExtValue[float]
    "Change weight"
    f1_xo_propor: ExtValue[int]
    """
    Proportional crossover
    
    Cross over (exchange) corresponding segments of the two parent genotypes?
    
    f1 uses a two-point crossing over.
    If this option is turned on, cut points will be selected proportionally to neural genes in both parents, and a similar number of characters will be exchanged if possible.
    Thus, if both parents have the same number of neurons, then this will be preserved in their children.
    """
    f1_smX: ExtValue[float]
    "Add/remove a stick X"
    f1_smJunct: ExtValue[float]
    "Add/remove a branch ( )"
    f1_smComma: ExtValue[float]
    "Add/remove a comma ,"
    f1_smModif: ExtValue[float]
    """
    Add/remove a modifier
    
    Modifiers: LlRrCcQqFfMmEeWwSsAaIiDdGgBb
    """
    f1_smModifiers: ExtValue[str]
    """
    Allowed modifiers
    
    Modifier symbols that will be added or deleted during mutation
    (from the full set: LlRrCcQqFfMmEeWwSsAaIiDdGgBb).
    
    You may use the extended syntax: after every allowed symbol, you may include its probability value in parentheses.
    Without parentheses, all allowed symbols behave as if they had (1.0) appended.
    If you include (0.0) after a symbol, this bans that symbol as if it was not present in this string.
    """
    f1_nmNeu: ExtValue[float]
    """
    Add/remove a neuron
    
    Adds a (connected) neuron or removes a neuron
    """
    f1_nmConn: ExtValue[float]
    "Add/remove neural connection"
    f1_nmProp: ExtValue[float]
    "Add/remove neuron property setting"
    f1_nmWei: ExtValue[float]
    "Change connection weight"
    f1_nmVal: ExtValue[float]
    "Change property value"
    f4_mut_add: ExtValue[float]
    """
    Add node
    
    Mutation: probability of adding a node
    """
    f4_mut_add_div: ExtValue[float]
    """
    - add division
    
    Add node mutation: probability of adding a division
    """
    f4_mut_add_conn: ExtValue[float]
    """
    - add connection
    
    Add node mutation: probability of adding a neural connection
    """
    f4_mut_add_neupar: ExtValue[float]
    """
    - add neuron property
    
    Add node mutation: probability of adding a neuron property/modifier
    """
    f4_mut_add_rep: ExtValue[float]
    """
    - add repetition '#'
    
    Add node mutation: probability of adding the '#' repetition gene
    """
    f4_mut_add_simp: ExtValue[float]
    """
    - add simple node
    
    Add node mutation: probability of adding a random, simple gene
    """
    f4_mut_del: ExtValue[float]
    """
    Delete node
    
    Mutation: probability of deleting a node
    """
    f4_mut_mod: ExtValue[float]
    """
    Modify node
    
    Mutation: probability of changing a node
    """
    f4_mut_modneu_conn: ExtValue[float]
    """
    - neuron input: modify source
    
    Neuron input mutation: probability of changing its source neuron
    """
    f4_mut_modneu_weight: ExtValue[float]
    """
    - neuron input: modify weight
    
    Neuron input mutation: probability of changing its weight
    """
    f4_mut_max_rep: ExtValue[int]
    """
    Maximum number for '#' repetitions
    
    Maximum allowed number of repetitions for the '#' repetition gene
    """
    f4_mut_modifiers: ExtValue[str]
    """
    Allowed modifiers
    
    Modifier symbols that will be added or deleted during mutation
    (from the full set: LlRrCcQqFfMmEeWwSsAaIiDdGgBb).
    
    You may use the extended syntax: after every allowed symbol, you may include its probability value in parentheses.
    Without parentheses, all allowed symbols behave as if they had (1.0) appended.
    If you include (0.0) after a symbol, this bans that symbol as if it was not present in this string.
    """
    f8_mut_chg_begin_arg: ExtValue[float]
    """
    Change beginning argument
    
    mutation: probability of changing a beginning argument
    """
    f8_mut_chg_arg: ExtValue[float]
    """
    Change argument
    
    mutation: probability of changing a production's argument
    """
    f8_mut_del_comm: ExtValue[float]
    """
    Delete command
    
    mutation: probability of deleting a command
    """
    f8_mut_insert_comm: ExtValue[float]
    """
    Insert commands
    
    mutation: probability of inserting commands
    """
    f8_mut_enc: ExtValue[float]
    """
    Encapsulate commands
    
    mutation: probability of encapsulating commands
    """
    f8_mut_chg_cond_sign: ExtValue[float]
    """
    Change condition sign
    
    mutation: probability of changing a condition sign
    """
    f8_mut_add_param: ExtValue[float]
    """
    Add parameter
    
    mutation: probability of adding a parameter to the production
    """
    f8_mut_add_cond: ExtValue[float]
    """
    Add condition
    
    mutation: probability of adding a condition to the subproduction
    """
    f8_mut_add_subprod: ExtValue[float]
    """
    Add subproduction
    
    mutation: probability of adding a subproduction
    """
    f8_mut_chg_iter_number: ExtValue[float]
    """
    Change iteration number
    
    mutation: probability of changing a number of iterations
    """
    f8_mut_del_param: ExtValue[float]
    """
    Delete parameter
    
    mutation: probability of deleting a parameter
    """
    f8_mut_del_cond: ExtValue[float]
    """
    Delete condition
    
    mutation: probability of deleting a condition
    """
    f8_mut_add_loop: ExtValue[float]
    """
    Add loop
    
    mutation: probability of adding a loop
    """
    f8_mut_del_loop: ExtValue[float]
    """
    Delete loop
    
    mutation: probability of deleting a loop
    """
    f8_mut_del_prod: ExtValue[float]
    """
    Delete production
    
    mutation: probability of deleting a production
    """
    f9_mut: ExtValue[float]
    """
    Mutation probability
    
    How many genes should be mutated during a single mutation (1=all genes, 0.1=ten percent, 0=one gene)
    """
    fF_xover: ExtValue[float]
    """
    Inherited in linear mix crossover
    
    0.5 => children are averaged parents.
    0.8 => children are only 20% different from parents.
    1.0 => each child is identical to one parent (no crossover).
    """
    fn_xover: ExtValue[float]
    """
    Fraction inherited in linear mix crossover
    
    0.5 => children are averaged parents.
    0.8 => children are only 20% different from parents.
    1.0 => each child is identical to one parent (no crossover).
    """
    fn_xover_random: ExtValue[int]
    """
    Random fraction inherited in crossover
    
    If active, the amount of linear mix is random in each crossover operation, so the "Fraction inherited in linear mix crossover" parameter is ignored.
    """
    fn_mut_bound_low: ExtValue[str]
    """
    Lower bounds for mutation
    
    A vector of lower bounds (one real value for each variable)
    """
    fn_mut_bound_high: ExtValue[str]
    """
    Higher bounds for mutation
    
    A vector of higher bounds (one real value for each variable)
    """
    fn_mut_stddev: ExtValue[str]
    """
    Standard deviations for mutation
    
    A vector of standard deviations (one real value for each variable)
    """
    fn_mut_single_var: ExtValue[int]
    """
    Mutate only a single variable
    
    If active, only a single randomly selected variable will be mutated in each mutation operation. Otherwise all variables will be mutated.
    """
    fB_mut_substitute: ExtValue[float]
    """
    Substitution
    
    Relative probability of changing a single random character (or a neuron) in the genotype
    """
    fB_mut_insert: ExtValue[float]
    """
    Insertion
    
    Relative probability of inserting a random character in a random place of the genotype
    """
    fB_mut_insert_neuron: ExtValue[float]
    """
    Insertion of a neuron
    
    Relative probability of inserting a neuron in a random place of genotype
    """
    fB_mut_delete: ExtValue[float]
    """
    Deletion
    
    Relative probability of deleting a random character (or a neuron) in the genotype
    """
    fB_mut_duplicate: ExtValue[float]
    """
    Duplication
    
    Relative probability of copying a single *gene* of the genotype and appending it to the beginning of this genotype
    """
    fB_mut_translocate: ExtValue[float]
    """
    Translocation
    
    Relative probability of swapping two substrings in the genotype
    """
    fB_cross_gene_transfer: ExtValue[float]
    """
    Horizontal gene transfer
    
    Relative probability of crossing over by copying a single random gene from each parent to the beginning of the other parent
    """
    fB_cross_crossover: ExtValue[float]
    """
    Crossing over
    
    Relative probability of crossing over by a random distribution of genes from both parents to both children
    """
    fH_mut_addition: ExtValue[float]
    """
    Add element
    
    Probability of adding a new element
    """
    fH_mut_add_joint: ExtValue[float]
    """
    - add joint
    
    Probability of adding a new stick handle
    """
    fH_mut_add_neuron: ExtValue[float]
    """
    - add neuron
    
    Probability of adding a new neuron handle
    """
    fH_mut_add_connection: ExtValue[float]
    """
    - add neural connection
    
    Probability of adding a new neuron connection handle
    """
    fH_mut_deletion: ExtValue[float]
    """
    Delete element
    
    Probability of removing an element
    """
    fH_mut_handle: ExtValue[float]
    """
    Modify vectors of handles
    
    Probability of changing values in vectors of a handle
    """
    fH_mut_property: ExtValue[float]
    """
    Modify properties of handles
    
    Probability of changing properties of handles
    """
    fL_maxdefinedwords: ExtValue[int]
    """
    Maximum number of defined words
    
    Maximum number of words that can be defined in the L-System
    """
    fL_axm_mut_prob: ExtValue[float]
    """
    Axiom mutation
    
    Probability of performing mutation operations on axiom
    """
    fL_rul_mut_prob: ExtValue[float]
    """
    Rule's successor mutation
    
    Probability of performing mutation operations on the successor of a random rule
    """
    fL_mut_addition: ExtValue[float]
    """
    Addition of a word to a sequence
    
    Probability of adding a random existing word to the axiom or to one of successors
    """
    fL_mut_add_stick: ExtValue[float]
    """
    - addition of a stick
    
    Probability of adding a stick
    """
    fL_mut_add_neuro: ExtValue[float]
    """
    - addition of a neuron
    
    Probability of adding a neuron
    """
    fL_mut_add_conn: ExtValue[float]
    """
    - addition of a neuron connection
    
    Probability of adding a neuron connection
    """
    fL_mut_add_rot: ExtValue[float]
    """
    - addition of rotation words
    
    Probability of adding one of rotation words
    """
    fL_mut_add_branch: ExtValue[float]
    """
    - addition of a branched stick
    
    Probability of adding a branch with a rotation and a stick
    """
    fL_mut_add_other: ExtValue[float]
    """
    - addition of defined words
    
    Probability of adding another word defined in the genotype
    """
    fL_mut_worddefaddition: ExtValue[float]
    """
    Addition of a new word definition
    
    Probability of adding a new word definition to the genotype
    """
    fL_mut_ruleaddition: ExtValue[float]
    """
    Addition of a new rule definition
    
    Probability of adding a new rule definition for an existing word
    """
    fL_mut_rulecond: ExtValue[float]
    """
    Modification of a rule condition
    
    Probability of modifying a random rule condition
    """
    fL_mut_changeword: ExtValue[float]
    """
    Change a random word
    
    Probability of changing a word name or a formula of a random word from an axiom or one of successors
    """
    fL_mut_changeword_formula: ExtValue[float]
    """
    - change of a formula
    
    Probability of changing a formula in a word
    """
    fL_mut_changeword_name: ExtValue[float]
    """
    - change of a name
    
    Probability of changing a name in a word
    """
    fL_mut_changeiter: ExtValue[float]
    """
    Change the number of iterations
    
    Probability of changing the number of iterations of the L-System
    """
    fL_mut_changeiter_step: ExtValue[float]
    """
    Step of the iteration change
    
    The minimal step that should be used for changing iterations in the L-System
    """
    fL_mut_deletion: ExtValue[float]
    """
    Deletion of a random word
    
    Probability of deleting a random word from an axiom or a random successor (also deletes the rule if there is only one word in the successor)
    """
    fS_mut_add_part: ExtValue[float]
    """
    Add part
    
    mutation: probability of adding a part
    """
    fS_mut_rem_part: ExtValue[float]
    """
    Remove part
    
    mutation: probability of deleting a part
    """
    fS_mut_mod_part: ExtValue[float]
    """
    Modify part
    
    mutation: probability of changing the part type
    """
    fS_mut_change_joint: ExtValue[float]
    """
    Change joint
    
    mutation: probability of changing a joint
    """
    fS_mut_add_param: ExtValue[float]
    """
    Add param
    
    mutation: probability of adding a parameter
    """
    fS_mut_rem_param: ExtValue[float]
    """
    Remove param
    
    mutation: probability of removing a parameter
    """
    fS_mut_mod_param: ExtValue[float]
    """
    Modify param
    
    mutation: probability of modifying a parameter
    """
    fS_mut_mod_mod: ExtValue[float]
    """
    Modify modifier
    
    mutation: probability of modifying a modifier
    """
    fS_mut_add_neuro: ExtValue[float]
    """
    Add neuron
    
    mutation: probability of adding a neuron
    """
    fS_mut_rem_neuro: ExtValue[float]
    """
    Remove neuron
    
    mutation: probability of removing a neuron
    """
    fS_mut_mod_neuro_conn: ExtValue[float]
    """
    Modify neuron connection
    
    mutation: probability of changing a neuron connection
    """
    fS_mut_add_neuro_conn: ExtValue[float]
    """
    Add neuron connection
    
    mutation: probability of adding a neuron connection
    """
    fS_mut_rem_neuro_conn: ExtValue[float]
    """
    Remove neuron connection
    
    mutation: probability of removing a neuron connection
    """
    fS_mut_mod_neuro_params: ExtValue[float]
    """
    Modify neuron params
    
    mutation: probability of changing a neuron param
    """
    fS_circle_section: ExtValue[int]
    """
    Ensure circle section
    
    Ensure that ellipsoids and cylinders have circle cross-section
    """
    fS_use_elli: ExtValue[int]
    """
    Use ellipsoids in mutations
    
    Use ellipsoids in mutations
    """
    fS_use_cub: ExtValue[int]
    """
    Use cuboids in mutations
    
    Use cuboids in mutations
    """
    fS_use_cyl: ExtValue[int]
    """
    Use cylinders in mutations
    
    Use cylinders in mutations
    """
    fS_mut_add_part_strong: ExtValue[int]
    """
    Strong add part mutation
    
    Add part mutation will produce more parametrized parts
    """
    genoconv_f1_f0: ExtValue[int]
    "f1 --> f0  :  Recursive encoding"
    genoconv_f4_f0: ExtValue[int]
    "f4 --> f0  :  Developmental encoding"
    genoconv_f8_f1: ExtValue[int]
    "f8 --> f1  :  (Old) generative encoding"
    genoconv_f9_f0: ExtValue[int]
    "f9 --> f0  :  Turtle3D-ortho encoding"
    genoconv_fF_f0s: ExtValue[int]
    "fF --> f0s  :  10-parameter Foraminifera encoding"
    genoconv_fn_f0: ExtValue[int]
    "fn --> f0  :  Vector of real values, no phenotype"
    genoconv_fB_fH: ExtValue[int]
    "fB --> fH  :  Biological encoding"
    genoconv_fH_f0: ExtValue[int]
    "fH --> f0  :  Similarity encoding"
    genoconv_fL_f0: ExtValue[int]
    "fL --> f0  :  L-System encoding"
    genoconv_fS_f0s: ExtValue[int]
    "fS --> f0s  :  Solids tree-structure encoding"
    conv_f1_f0_modcompat: ExtValue[int]
    """
    Modifier compatibility
    
    The modern implementation makes the influence of modifiers more consistent and uniform, and the extreme property values are easier to reach with a lower number of characters, which improves the topology for evolutionary search.
    Previous implementation can be enabled for compatibility, for example when you want to test old genotypes.
    """
    conv_f1_f0_cq_influence: ExtValue[int]
    """
    'C' and 'Q' modifier influence
    
    'C' and 'Q' modifier semantics was changed in June 2023. Previously they did not affect the stick immediately following the current sequence of modifiers. In the modern implementation, all modifiers consistently start their influence at the very next stick that is being created in the current branch.
    Example:
    In the old interpretation of 'XcXX', only the last stick is rotated, because 'c' starts its influence at the stick that occurs after the current stick. In the modern implementation, the same effect is achieved with 'XXcX', where 'c' immediately bends the first 'X' that appears after it.
    Previous implementation can be enabled for compatibility, for example when you want to test old genotypes.
    """
    conv_f1_f0_branch_muscle_range: ExtValue[int]
    """
    Bending muscle default range
    
    Determines how the bending muscle default turning range is limited when the muscle is controlling a stick growing from a branching point that has 'NumberOfBranches' sticks separated by commas. The motivation of the limited range is to keep the neighboring sticks from intersecting when they are bent by muscles. This constraint may degrade the performance (e.g. velocity) of creatures, but this default value can be overridden by providing a specific range property value for the '|' muscle neuron in the genotype.
    - Full/NumberOfBranches - a compromise between the two other settings.
    - Full/(NumberOfBranches+1) - because the originating stick also counts as a branch. This setting guarantees that in the worst case, when at least two neighboring branches have sticks controlled by bending muscles and their controlling signals are at extreme values, the sticks can touch and overlap, but will not intersect. This setting is in most cases too strict because (1) all branches are very rarely controlled by muscles, (2) there are often 'empty' branches - multiple commas with no sticks in-between, and (3) the share of the originating stick is effectively wasted because this stick itself has no muscle at the branching point so it will not bend; the muscle bending range is symmetrical and the default range is equal for all muscles in a branching, but the sticks equipped with muscles in a branching are rarely evenly spaced.
    - Full: always the complete angle - because we do not have to care about the physical plausibility and avoid intersecting sticks, and other genetic representations do not impose such constraints, so this full angle setting can be useful as the default bending range when comparing the performance of various genetic encodings.
    """
    conv_f8_f1_maxlen: ExtValue[int]
    """
    Maximal genotype length
    
    Maximal length of the resulting f1 genotype, in characters. If the f8 L-system produces longer f1 genotype, it will be considered invalid.
    """
    randinit: ExtValue[float]
    """
    Random initialization
    
    Allowed range for initializing all neuron states with uniform distribution random numbers and zero mean. Set to 0 for deterministic initialization.
    """
    nnoise: ExtValue[float]
    """
    Noise
    
    Gaussian neural noise: a random value is added to each neural output in each simulation step. Set standard deviation here to add random noise, or 0 for deterministic simulation.
    """
    touchrange: ExtValue[float]
    "T receptor range"
    bnoise_struct: ExtValue[float]
    """
    Body disturbance
    
    When >0, body constructs of creatures (position of Parts) will be randomly disturbed when they are created.
    """
    bnoise_vel: ExtValue[float]
    """
    Initial movement
    
    Random velocities will be applied to all body Parts (in MechaStick) or rigid segments (in ODE) of newly created creatures.
    """
    ncl_N: ExtValue[int]
    """
    Neuron (N)
    
    Standard neuron
    
    Characteristics:
       supports any number of inputs
       provides output value
       does not require location in body
    
    
    Properties:
       Inertia (in) float 0..1 (default 0.8)
       Force (fo) float 0..999 (default 0.04)
       Sigmoid (si) float -99999..99999 (default 2)
       State (s) float -1..1 (default 0)
    """
    ncl_Nu: ExtValue[int]
    """
    Unipolar neuron [EXPERIMENTAL!] (Nu)
    
    Works like standard neuron (N) but the output value is scaled to 0...+1 instead of -1...+1.
    Having 0 as one of the saturation states should help in "gate circuits", where input signal is passed through or blocked depending on the other singal.
    
    Characteristics:
       supports any number of inputs
       provides output value
       does not require location in body
    
    
    Properties:
       Inertia (in) float 0..1 (default 0.8)
       Force (fo) float 0..999 (default 0.04)
       Sigmoid (si) float -99999..99999 (default 2)
       State (s) float -1..1 (default 0)
    """
    ncl_G: ExtValue[int]
    """
    Gyroscope (G)
    
    Tilt sensor.
    Signal is proportional to sin(angle) = most sensitive in horizontal orientation.
    0=the stick is horizontal
    +1/-1=the stick is vertical
    
    Characteristics:
       does not use inputs
       provides output value
       should be located on a Joint
    """
    ncl_Gpart: ExtValue[int]
    """
    Part Gyroscope (Gpart)
    
    Tilt sensor. Signal is directly proportional to the tilt angle.
    0=the part X axis is horizontal
    +1/-1=the axis is vertical
    
    Characteristics:
       does not use inputs
       provides output value
       should be located on a Part
    
    
    Properties:
       rotation.y (ry) float -6.282..6.282 (default 0)
       rotation.z (rz) float -6.282..6.282 (default 0)
    """
    ncl_T: ExtValue[int]
    """
    Touch (T)
    
    Touch and proximity sensor (Tcontact and Tproximity combined)
    -1=no contact
    0=just touching
    >0=pressing, value depends on the force applied (not implemented in ODE mode)
    
    Characteristics:
       does not use inputs
       provides output value
       should be located on a Part
    
    
    Properties:
       Range (r) float 0..1 (default 1)
       rotation.y (ry) float -6.282..6.282 (default 0)
       rotation.z (rz) float -6.282..6.282 (default 0)
    """
    ncl_Tcontact: ExtValue[int]
    """
    Touch contact (Tcontact)
    
    Touch sensor.
    -1=no contact
    0=the Part is touching the obstacle
    >0=pressing, value depends on the force applied (not implemented in ODE mode)
    
    Characteristics:
       does not use inputs
       provides output value
       should be located on a Part
    """
    ncl_Tproximity: ExtValue[int]
    """
    Touch proximity (Tproximity)
    
    Proximity sensor detecting obstacles along the X axis.
    -1=distance is "r" or more
    0=zero distance
    
    Characteristics:
       does not use inputs
       provides output value
       should be located on a Part
    
    
    Properties:
       Range (r) float 0..1 (default 1)
       rotation.y (ry) float -6.282..6.282 (default 0)
       rotation.z (rz) float -6.282..6.282 (default 0)
    """
    ncl_S: ExtValue[int]
    """
    Smell (S)
    
    Smell sensor. Aggregated "smell of energy" experienced from all energy objects (creatures and food pieces).
    Close objects have bigger influence than the distant ones: for each energy source, its partial feeling is proportional to its energy/(distance^2)
    
    Characteristics:
       does not use inputs
       provides output value
       should be located on a Part
    """
    ncl_Constant: ExtValue[int]
    """
    Constant (*)
    
    Constant value
    
    Characteristics:
       does not use inputs
       provides output value
       does not require location in body
    """
    ncl_Bend_muscle: ExtValue[int]
    """
    Bend muscle (|)
    
    Characteristics:
       uses single input
       does not provide output value
       should be located on a Joint
    
    
    Properties:
       power (p) float 0..1 (default 0.25)
       bending range (r) float 0..1 (default 1)
    """
    ncl_Rotation_muscle: ExtValue[int]
    """
    Rotation muscle (@)
    
    Characteristics:
       uses single input
       does not provide output value
       should be located on a Joint
    
    
    Properties:
       power (p) float 0..1 (default 1)
    """
    ncl_M: ExtValue[int]
    """
    Muscle for solids (M)
    
    Characteristics:
       uses single input
       does not provide output value
       should be located on a Joint
    
    
    Properties:
       power (p) float 0..1 (default 1)
       axis (a) integer 0..1 (default 0)
    """
    ncl_D: ExtValue[int]
    """
    Differentiate (D)
    
    Calculate the difference between the current and previous input value. Multiple inputs are aggregated with respect to their weights
    
    Characteristics:
       supports any number of inputs
       provides output value
       does not require location in body
    """
    ncl_Fuzzy: ExtValue[int]
    """
    Fuzzy system [EXPERIMENTAL!] (Fuzzy)
    
    Refer to publications to learn more about this neuron.
    
    Characteristics:
       supports any number of inputs
       provides output value
       does not require location in body
    
    
    Properties:
       number of fuzzy sets (ns) integer
       number of rules (nr) integer
       fuzzy sets (fs) string (default "")
       fuzzy rules (fr) string (default "")
    """
    ncl_VEye: ExtValue[int]
    """
    Vector Eye [EXPERIMENTAL!] (VEye)
    
    Refer to publications to learn more about this neuron.
    
    Characteristics:
       uses single input
       provides output value
       should be located on a Part
    
    
    Properties:
       target.x (tx) float
       target.y (ty) float
       target.z (tz) float
       target shape (ts) string (default "")
       perspective (p) float 0.1..10 (default 1)
       scale (s) float 0.1..100 (default 1)
       show hidden lines (h) integer 0..1 (default 0)
       output lines count (each line needs four channels) (o) integer 0..99 (default 0)
       debug (d) integer 0..1 (default 0)
    """
    ncl_VMotor: ExtValue[int]
    """
    Visual-Motor Cortex [EXPERIMENTAL!] (VMotor)
    
    Must be connected to the VEye and properly set up. Refer to publications to learn more about this neuron.
    
    Characteristics:
       supports any number of inputs
       provides output value
       does not require location in body
    
    
    Properties:
       number of basic features (noIF) integer
       number of degrees of freedom (noDim) integer
       parameters (params) string
    """
    ncl_Sti: ExtValue[int]
    """
    Sticky [EXPERIMENTAL!] (Sti)
    
    Characteristics:
       uses single input
       does not provide output value
       should be located on a Part
    """
    ncl_LMu: ExtValue[int]
    """
    Linear muscle [EXPERIMENTAL!] (LMu)
    
    Characteristics:
       uses single input
       does not provide output value
       should be located on a Joint
    
    
    Properties:
       power (p) float 0.01..1 (default 1)
    """
    ncl_Water: ExtValue[int]
    """
    Water detector (Water)
    
    Output signal:
    0=on or above water surface
    1=under water (deeper than 1)
    0..1=in the transient area just below water surface
    
    Characteristics:
       does not use inputs
       provides output value
       should be located on a Part
    """
    ncl_Energy: ExtValue[int]
    """
    Energy level (Energy)
    
    The current energy level divided by the initial energy level.
    Usually falls from initial 1.0 down to 0.0 and then the creature dies. It can rise above 1.0 if enough food is ingested
    
    Characteristics:
       does not use inputs
       provides output value
       does not require location in body
    """
    ncl_Ch: ExtValue[int]
    """
    Channelize (Ch)
    
    Combines all input signals into a single multichannel output; Note: ChSel and ChMux are the only neurons which support multiple channels. Other neurons discard everything except the first channel.
    
    Characteristics:
       supports any number of inputs
       provides output value
       does not require location in body
    """
    ncl_ChMux: ExtValue[int]
    """
    Channel multiplexer (ChMux)
    
    Outputs the selected channel from the second (multichannel) input. The first input is used as the selector value (-1=select first channel, .., 1=last channel)
    
    Characteristics:
       uses 2 inputs
       provides output value
       does not require location in body
    """
    ncl_ChSel: ExtValue[int]
    """
    Channel selector (ChSel)
    
    Outputs a single channel (selected by the "ch" parameter) from multichannel input
    
    Characteristics:
       uses single input
       provides output value
       does not require location in body
    
    
    Properties:
       channel (ch) integer
    """
    ncl_Rnd: ExtValue[int]
    """
    Random noise (Rnd)
    
    Generates random noise (subsequent random values in the range of -1..+1)
    
    Characteristics:
       does not use inputs
       provides output value
       does not require location in body
    """
    ncl_Sin: ExtValue[int]
    """
    Sinus generator (Sin)
    
    Output frequency = f0+input
    
    Characteristics:
       uses single input
       provides output value
       does not require location in body
    
    
    Properties:
       base frequency (f0) float -1..1 (default 0.0628319)
       time (t) float 0..6.28319 (default 0)
    """
    simil_type: ExtValue[int]
    "Type of similarity measure"

    @staticmethod
    def evaluateDistance(_: "Geno", __2: "Geno") -> ExtValue[float]:
        """
        Evaluate model dissimilarity

        Calculates dissimilarity between two models created from Geno objects.
        """
        ...

    simil_greedy_parts: ExtValue[float]
    """
    Weight of parts count
    
    Differing number of parts is also handled by the 'part degree' similarity component.
    """
    simil_greedy_partdeg: ExtValue[float]
    "Weight of parts' degree"
    simil_greedy_neuro: ExtValue[float]
    "Weight of neurons count"
    simil_greedy_partgeom: ExtValue[float]
    "Weight of parts' geometric distances"
    simil_greedy_fixedZaxis: ExtValue[int]
    "Fix 'z' (vertical) axis?"
    simil_greedy_weightedMDS: ExtValue[int]
    """
    Should weighted MDS be used?
    
    If activated, weighted MDS with vertex (i.e., Part) degrees as weights is used for 3D alignment of body structure.
    """
    simil_parts: ExtValue[float]
    """
    Weight of parts count
    
    Differing number of parts is also handled by the 'part degree' similarity component.
    """
    simil_partdeg: ExtValue[float]
    "Weight of parts' degree"
    simil_neuro: ExtValue[float]
    "Weight of neurons count"
    simil_partgeom: ExtValue[float]
    "Weight of parts' geometric distances"
    simil_fixedZaxis: ExtValue[int]
    "Fix 'z' (vertical) axis?"
    simil_weightedMDS: ExtValue[int]
    """
    Should weighted MDS be used?
    
    If activated, weighted MDS with vertex (i.e., Part) degrees as weights is used for 3D alignment of body structure.
    """
    simil_density: ExtValue[float]
    "Density of surface sampling"
    simil_bin_num: ExtValue[int]
    "Number of bins"
    simil_samples_num: ExtValue[int]
    "Number of samples"

    @staticmethod
    def calculateSymmetry(model: "Model") -> ExtValue[float]:
        """
        Calculate symmetry

        Returns bilateral symmetry (0.0 .. 1.0) for a given Model using default precision parameters (symPosSteps,symAlphaSteps,symBetaSteps). Returns the symmetry plane, too (sets symResultA,B,C,D).
        Note: may take a long time for large creatures.
        """
        ...

    @staticmethod
    def calculateSymmetry2(model: "Model", posSteps: int, alphaSteps: int, betaSteps: int) -> ExtValue[float]:
        """
        Calculate symmetry

        Returns bilateral symmetry (0.0 .. 1.0) for a given Model using specified precision parameters. Returns the symmetry plane, too (sets symResultA,B,C,D).
        Note: may take a long time for large creatures.
        """
        ...

    @staticmethod
    def calculateSymmetryForPlane(model: "Model", A: float, B: float, C: float, D: float) -> ExtValue[float]:
        """
        Calculate symmetry

        Returns bilateral symmetry (0.0 .. 1.0) for a given Model and given a specific plane defined by coefficients A, B, C, D.
        """
        ...

    symPosSteps: ExtValue[int]
    """
    Position sampling
    
    Default number of samples per stick length
    """
    symAlphaSteps: ExtValue[int]
    """
    Angular sampling (1)
    
    Default number of samples per full angle (#1)
    """
    symBetaSteps: ExtValue[int]
    """
    Angular sampling (2)
    
    Default number of samples per full angle (#2)
    """
    symResultA: ExtValue[float]
    "resulting symmetry plane, coeff. A (set by calculateSymmetry)"
    symResultB: ExtValue[float]
    "resulting symmetry plane, coeff. B (set by calculateSymmetry)"
    symResultC: ExtValue[float]
    "resulting symmetry plane, coeff. C (set by calculateSymmetry)"
    symResultD: ExtValue[float]
    "resulting symmetry plane, coeff. D (set by calculateSymmetry)"
    geom_density: ExtValue[float]
    """
    Density
    
    The number of samples (per unit length in one dimension) that affects the precision of estimation of geometrical properties.
    """

    @staticmethod
    def forModel(_: "Model") -> ExtValue:  # returns ModelGeometry
        "The returned ModelGeometry object can be used to calculate geometric properties (volume, area, sizes) of the associated model. The density is copied from the current global ModelGeometry.geom_density on object creation."
        ...

    @staticmethod
    def volume() -> ExtValue[float]: ...

    @staticmethod
    def area() -> ExtValue[float]: ...

    @staticmethod
    def voxels() -> ExtValue:  # returns Vector
        "Returns a Vector of Pt3D objects from a regular 3D grid (sampled according to ModelGeometry.geom_density) that are inside of the Model body (Parts and Joints)."
        ...

    @staticmethod
    def sizesAndAxes() -> ExtValue:  # returns Vector
        "The returned vector contains XYZ (sizes) and Orient (axes) objects."
        ...

    minjoint: ExtValue[float]
    "Minimal joint length"
    maxjoint: ExtValue[float]
    "Maximal joint length"


class SimilMeasure(ExtValue):
    """
    Evaluates morphological dissimilarity. More information:
    http://www.framsticks.com/bib/Komosinski-et-al-2001
    http://www.framsticks.com/bib/Komosinski-and-Kubiak-2011
    http://www.framsticks.com/bib/Komosinski-2016
    https://doi.org/10.1007/978-3-030-16692-2_8
    """

    simil_type: ExtValue[int]
    "Type of similarity measure"

    @staticmethod
    def evaluateDistance(_: "Geno", __2: "Geno") -> ExtValue[float]:
        """
        Evaluate model dissimilarity

        Calculates dissimilarity between two models created from Geno objects.
        """
        ...


class SimilMeasureDistribution(ExtValue):
    "Evaluates morphological dissimilarity using the distribution measure."

    simil_density: ExtValue[float]
    "Density of surface sampling"
    simil_bin_num: ExtValue[int]
    "Number of bins"
    simil_samples_num: ExtValue[int]
    "Number of samples"

    @staticmethod
    def evaluateDistance(_: "Geno", __2: "Geno") -> ExtValue[float]:
        """
        Evaluate model dissimilarity

        Calculates dissimilarity between two models created from Geno objects.
        """
        ...


class SimilMeasureGreedy(ExtValue):
    """
    Evaluates morphological dissimilarity using the greedy measure. More information:
    http://www.framsticks.com/bib/Komosinski-et-al-2001
    http://www.framsticks.com/bib/Komosinski-and-Kubiak-2011
    http://www.framsticks.com/bib/Komosinski-2016
    https://www.framsticks.com/bib/Komosinski-and-Mensfelt-2019
    """

    simil_greedy_parts: ExtValue[float]
    """
    Weight of parts count
    
    Differing number of parts is also handled by the 'part degree' similarity component.
    """
    simil_greedy_partdeg: ExtValue[float]
    "Weight of parts' degree"
    simil_greedy_neuro: ExtValue[float]
    "Weight of neurons count"
    simil_greedy_partgeom: ExtValue[float]
    "Weight of parts' geometric distances"
    simil_greedy_fixedZaxis: ExtValue[int]
    "Fix 'z' (vertical) axis?"
    simil_greedy_weightedMDS: ExtValue[int]
    """
    Should weighted MDS be used?
    
    If activated, weighted MDS with vertex (i.e., Part) degrees as weights is used for 3D alignment of body structure.
    """

    @staticmethod
    def evaluateDistance(_: "Geno", __2: "Geno") -> ExtValue[float]:
        """
        Evaluate model dissimilarity

        Calculates dissimilarity between two models created from Geno objects.
        """
        ...


class SimilMeasureHungarian(ExtValue):
    """
    Evaluates morphological dissimilarity using the measure. More information:
    http://www.framsticks.com/bib/Komosinski-et-al-2001
    http://www.framsticks.com/bib/Komosinski-and-Kubiak-2011
    http://www.framsticks.com/bib/Komosinski-2016
    https://www.framsticks.com/bib/Komosinski-and-Mensfelt-2019
    """

    simil_parts: ExtValue[float]
    """
    Weight of parts count
    
    Differing number of parts is also handled by the 'part degree' similarity component.
    """
    simil_partdeg: ExtValue[float]
    "Weight of parts' degree"
    simil_neuro: ExtValue[float]
    "Weight of neurons count"
    simil_partgeom: ExtValue[float]
    "Weight of parts' geometric distances"
    simil_fixedZaxis: ExtValue[int]
    "Fix 'z' (vertical) axis?"
    simil_weightedMDS: ExtValue[int]
    """
    Should weighted MDS be used?
    
    If activated, weighted MDS with vertex (i.e., Part) degrees as weights is used for 3D alignment of body structure.
    """

    @staticmethod
    def evaluateDistance(_: "Geno", __2: "Geno") -> ExtValue[float]:
        """
        Evaluate model dissimilarity

        Calculates dissimilarity between two models created from Geno objects.
        """
        ...


class Simulator(ExtValue):
    "The Framsticks simulator."

    @staticmethod
    def print(text: str) -> ExtValue[None]:
        """
        Print information message

        One argument: message to be printed.
        """
        ...

    @staticmethod
    def message(text: str, level: int) -> ExtValue[None]:
        """
        Print message

        The second argument can be:
         -1 = debugging message
         0 = information
         1 = warning
         2 = error
         3 = critical error
        """
        ...

    @staticmethod
    def sleep(milliseconds: int) -> ExtValue[None]:
        "Suspends the execution for a specified interval."
        ...

    @staticmethod
    def beep() -> ExtValue[None]:
        "Plays the default system sound."
        ...

    @staticmethod
    def sound(freqency_in_Hz: int, length_in_milliseconds: int) -> ExtValue[None]:
        "Generates a simple tone on the speaker"
        ...

    @staticmethod
    def eval(script_statement: str) -> ExtValue[None]:
        """
        Evaluate a statement

        The argument must be a complete statement, e.g. "return 2+2;" is valid, while "2+2" is not. The Error object is returned for invalid statements.
        Example:
        var statement="function fun(a) {return a*a;} return fun(Math.pi);";
        var result=Simulator.eval(statement);
        if (typeof result=="Error")
           Simulator.print("Error:"+result.message);
        else
           Simulator.print("Result:"+result);
        """
        ...

    @staticmethod
    def load(filename: str) -> ExtValue[None]:
        'Load experiment file (calls onExpLoad() in the current experiment definition). This function is intended to replace the simulator state; the old state is cleared by automatically calling "resetToDefaults()". Use "import" if you don\'t want to lose the old simulator state. Contents can also be loaded from string by using specifically formed filename: "string://string_contents_to_be_loaded".'
        ...

    @overload
    @staticmethod
    def import_(filename: str, options: int) -> ExtValue[None]:
        """
        Import some data from file. Contents can also be imported from string by using specifically formed filename: "string://string_contents_to_be_imported".
        The second optional argument selects what section(s) will be imported:
                1 - experiment (works just like load(), all other bits are ignored, and can reset the simulator state!)
                2 - genotypes
                4 - simulator parameters
                8 - genepool settings
                16 - population settings
                32 - new groups will be created for imported genepools and populations
                64 - allow switching to a different expdef while importing parameters (4)
                256 - creatures

        The standard behavior (without the second argument) is to import genotypes, parameters, and genepool and population settings (2+4+8+16). Note that "64" is not included by default, because the expdef change resets all simulator parameters, which contradicts the usual meaning of "import" in Framsticks ("add data", as opposed to "load" meaning "replace data"). Moreover, using the "64" option in scripts can be dangerous, especially all expdef and show scripts should always declare the proper expdef name in their header rather than change the expdef directly. Without the "64" option, it is always safe to "import" any file in a script regardless of the current simulator state.
        """
        ...

    @overload
    @staticmethod
    def import_(filename: str) -> ExtValue[None]:
        "Equivalent to import(filename,2+4+8+16) - imports genotypes, parameters, genepool and population settings."
        ...

    @staticmethod
    def save(filename: str) -> ExtValue:  # returns untyped
        "Save experiment file (calls onExpSave() in the current experiment definition). Providing null filename makes save() return saved data as a text string instead of writing it to the file."
        ...

    @staticmethod
    def export(filename: str, options: int, genepool: int, population: int) -> ExtValue:  # returns untyped
        """
        Save some data to file. Arguments:
        - filename: can be null, which makes export() return saved data as a text string instead of writing it to the file.
        - options: composed of the following bit values:
                1 - experiment (works just like save() and all other option bits are ignored)
                2 - genotypes
                4 - simulator parameters
                8 - simulator stats
                16 - genepool settings
                32 - population settings
                64 - do autosave
                256 - creatures
        - selected genepool, -1 means all genepools
        - selected population, -1 means all populations
        """
        ...

    @staticmethod
    def start() -> ExtValue[None]:
        """
        Start simulation

        Called by the user interface.
        """
        ...

    @staticmethod
    def stop() -> ExtValue[None]:
        """
        Stop simulation

        The expdef script calls this function to stop simulation.
        """
        ...

    running: ExtValue[int]
    """
    Is the simulation running?
    
    Useful for synchronizing the user interface state.
    """
    stop_on: ExtValue[int]
    """
    Error level to stop running simulation
    
    If the simulation is running and a message is emitted with at least the selected severity, the simulation will be stopped.
    """

    @staticmethod
    def step() -> ExtValue[None]:
        "Do a single simulation step"
        ...

    time: ExtValue[int]
    """
    Number of steps
    
    Simulator.time will be removed because of its misleading name, please use Simulator.stepNumber instead.
    """
    last_genotype_num: ExtValue[int]
    """
    Largest previously used Genotype.num
    
    See: Genotype.num
    """
    last_creature_num: ExtValue[int]
    """
    Largest previously used Creature.num
    
    See: Creature.num
    """
    stepNumber: ExtValue[int]
    "Number of simulation steps"
    simspeed: ExtValue[int]
    """
    Simulation speed
    
    steps/second
    """
    expdef: ExtValue[str]
    """
    Experiment definition
    
    Choose the experiment framework
    (in Windows GUI, confirm by pressing 'Apply')
    
    Stop the simulation before selecting another experiment definition.
    It is a good practice to initialize the experiment before running the simulation.
    """
    expdef_title: ExtValue[str]
    "Title"
    expdef_info: ExtValue[str]
    "Description"

    @staticmethod
    def init() -> ExtValue[None]:
        """
        Initialize experiment

        Prepares the experiment for running - usually performs initialization procedures such as resetting counters, states, gene pools, etc.
        These actions are defined in the onInit() function of this experiment definition.
        """
        ...

    @staticmethod
    def loadexpdef() -> ExtValue[None]:
        """
        Reload experiment definition

        Resets the simulator to its default state, resets all parameters to default values and then loads this experiment definition.
        """
        ...

    usercode: ExtValue[str]
    """
    Script override
    
    You can override any function from the original experiment definition script. Use the same function names and provide alternative implementations.
    Example:
    
    function onBorn(cr)
    {
      Simulator.print("A creature is born: "+cr.name);
      super_onBorn(cr); //calls the original implementation
    }
    """
    autosaveperiod: ExtValue[int]
    """
    Save backup
    
    Save simulation state once every n-th event
    (events are defined by the script. For 'standard.expdef' it is after each death).
    Save EXPT file first to initialize name for autosave files.
    Slave simulators (in multithreaded experiments) ignore this setting and never create autosave files.
    """
    overwrite: ExtValue[int]
    """
    Overwrite files?
    
    Lets you choose what to do when a file is created with the same name as an already existing file: overwite the existing file or create its backup?
    """
    filecomm: ExtValue[int]
    """
    Show file comments
    
    Controls displaying comments encountered in opened files.
    """

    @staticmethod
    def checkpoint() -> ExtValue[None]:
        """
        Notify that the experiment state was significantly updated.

        This function was previously called "autosave".
        """
        ...

    @staticmethod
    def checkpointData(any_data: Any) -> ExtValue[None]:
        """
        Notify that the experiment state was significantly updated + pass data.

        In the distributed/paralellized scenario the data passed as argument can be received by the controlling entity (onSlaveCheckpoint in multithreaded master experiment, /simulator/expevent in distributed network simulator).
        """
        ...

    lastCheckpoint: ExtValue  # untyped
    """
    Last checkpoint
    
    Most recently reported by the experiment definition script.
    """

    @staticmethod
    def resetToDefaults() -> ExtValue[None]:
        """
        Reset the simulator state

        Clears groups and loads default values for simulator parameters, then calls onExpDefLoad() of the current experiment definition.
        """
        ...

    createrr: ExtValue[int]
    "Object creation errors"
    groupchk: ExtValue[int]
    """
    Warn on adding invalid genotypes
    
    Warnings will be printed when invalid genotypes are added to a gene pool.
    """
    creatwarnfail: ExtValue[int]
    """
    Don't simulate genotypes with warnings
    
    Creatures grown with warnings will not be simulated. This helps prevent the propagation of faulty genes, because genotypes that cause warnings when interpreted will not reproduce.
    """
    vmdebug: ExtValue[int]
    "VM debug"
    vm_step_limit: ExtValue[int]
    """
    VM step limit
    
    Abort any script (expdef, fitness formula, user script) when it performs too many operations - which can take more or less time depending on your machine performance. This can protect against infinite loops or unbearably long runs of untested scripts that would otherwise force you to kill the whole application. Use Simulator.vm_..._warning if you only need information about what script takes too much time without aborting it.
    """
    vm_step_warning: ExtValue[int]
    """
    VM step warning
    
    Display a warning when any script (expdef, fitness formula, user script) performs too many operations - which can take more or less time depending on your machine performance. Use Simulator.vm_..._limit to prevent the application from becoming unresponsive by aborting misbehaving scripts.
    """
    vm_time_limit: ExtValue[float]
    """
    VM time limit
    
    Abort any script (expdef, fitness formula, user script) when it takes too much time - measured in seconds. The actual amount of work depends on your machine performance. This can protect against infinite loops or unbearably long runs of untested scripts that would otherwise force you to kill the whole application. Use Simulator.vm_..._warning if you only need information about what script takes too much time without aborting it.
    """
    vm_time_warning: ExtValue[float]
    """
    VM time warning
    
    Display a warning when any script (expdef, fitness formula, user script) takes too much time - measured in seconds. The actual amount of work depends on your machine performance. Use Simulator.vm_..._limit to prevent the application from becoming unresponsive by aborting misbehaving scripts.
    """

    @staticmethod
    def new() -> ExtValue:  # returns Simulator
        "create new Simulator"
        ...

    slaves: ExtValue  # SlaveSimulators
    "Slave simulator objects"
    cpus: ExtValue[int]
    "Number of detected CPUs ('cores') on this machine"
    world: ExtValue  # World
    populations: ExtValue  # Populations
    genepools: ExtValue  # GenePools
    "Gene pools object"
    expproperties: ExtValue  # ExpProperties
    expstate: ExtValue  # ExpState
    genman: ExtValue  # GenMan
    genoconverters: ExtValue  # GenoConverters
    "Genotype converters object"

    @staticmethod
    def reloadNeurons() -> ExtValue[None]:
        "Reload neuron definitions"
        ...

    userdata: ExtValue  # untyped
    "User field"
    identity: ExtValue[int]
    "-1 for master simulator, 0...count-1 for slaves"

    @staticmethod
    def refreshGUI() -> ExtValue[None]:
        """
        Refresh GUI

        Notify that all populations and gene pools content changed.
        """
        ...

    version_string: ExtValue[str]
    """
    Version string
    
    Current application version as a string (human-friendly).
    """
    version_int: ExtValue[int]
    """
    Version integer
    
    Current application version as an integer.
    """


class SlaveSimulators(ExtValue):
    """
    This is a vector of slave Simulator objects. More details in:
    http://www.framsticks.com/bib/Komosinski-and-Ulatowski-2013r
    http://www.framsticks.com/bib/Komosinski-and-Ulatowski-2016
    """

    size: ExtValue[int]
    """
    number of slaves
    
    Changing this value will create/remove slave simulator objects as needed.
    """

    @staticmethod
    def get(index: int) -> ExtValue:  # returns Simulator
        """
        Access the slave simulator object (Simulator.slaves[index] works, too).
        Important: Do not operate on a simulator that is currently running, always stop() it first.
        """
        ...

    running: ExtValue[int]
    """
    number of slaves running
    
    Note that if running>0 then the number of running simulations can be outdated in the very moment you read this field, because the expdef can stop itself anytime. If running==0, then it is guaranteed to stay 0 until someone calls start() on some of the slave simulator objects.
    """

    @staticmethod
    def create() -> ExtValue:  # returns Simulator
        """
        create a slave

        If you need to create AND store the reference to a newly created simulator object, then this function may be more readable than var s=Simulator.slaves[Simulator.slaves.size++];
        """
        ...

    @staticmethod
    def remove(slave_index_or_slave_Simulator_object_reference: Any) -> ExtValue[None]:
        """
        remove single slave

        Also calls stop() if the simulator is running. Events assocated with the simulator being deleted are cancelled, so the expdef will not see the usual onSlaveStop.
        """
        ...

    @staticmethod
    def removeAll():
        """
        remove all slaves

        Same as Simulator.slaves=0;
        """
        ...

    @staticmethod
    def startAll():
        "start all slaves"
        ...

    @staticmethod
    def stopAll():
        "stop all slaves"
        ...

    @staticmethod
    def cancelEventsFromSlave(_: "Simulator") -> ExtValue[None]:
        "If the onSlaveStop() event is used to schedule work to a simulator, then you might want to cancel pending events when the experiment is aborted - otherwise it may be difficult to distinguish between self-stop events (called internally from the slave simulator to signal the job was completed) from abort-stop events (requested by the supervising simulator). Calling Simulator.slaves.stopAll(); Simulator.slaves.cancelAllEvents(); makes sure that no old events will be detected after that time point. Without cancelling, the old onSlaveStop() notification (the consequence of the abort-stop) might arrive after the next start() which may confuse the expdef code (slave events are asynchronous)."
        ...

    @staticmethod
    def cancelAllEvents():
        "see cancelEventsFromSlave()"
        ...

    isolation: ExtValue[int]
    """
    slave isolation
    
    Slave simulator access is filtered to exclude object references across simulator boundaries and ensure a safe multithreaded operation.
    1. Slave simulations objects can't be accessed from master while the slave simulator is running (except for Simulator.stop/start/running).
    2. Master simulator objects can't be passed to slave simulators
    3. Data objects (Vectors and Dictionaries) are passed by value rather than by reference (to make sure that no simulator contains a reference to another simulator's data).
    Setting isolation=0 disables these restrictions, which can lead to unpredictable results or crashes, but is sometimes useful for inspecting true object relationships.
      Sample cases:
    Simulator.slaves[0].stop(); - always permitted
    Simulator.slaves[0].expdef="prime"; - permitted if the slave simulator is not running
    var vec=[1,2,3]; Simulator.slaves[0].user=vec; vec.clear(); - vec has changed, user field is still [1,2,3]
    var vec=[1,2,GenePools[0]]; Simulator.slaves[0].user=vec; - user field becomes [1,2,null] (because master's GenePool object can't be passed to the slave)
    var g=Simulator.slaves[0].genepools[0][0].genotype; - but the slave's GenePool can be accessed from master (if the slave is not running at the moment)
    """


class stats(ExtValue):
    gen_count: ExtValue[int]
    "Number of genetic operations so far"
    gen_mvalid: ExtValue[int]
    "Mutations valid"
    gen_mvalidated: ExtValue[int]
    "Mutations validated"
    gen_minvalid: ExtValue[int]
    """
    Mutations invalid
    
    couldn't be repaired
    """
    gen_mfailed: ExtValue[int]
    """
    Mutations failed
    
    couldn't be performed
    """
    gen_xovalid: ExtValue[int]
    "Crossovers valid"
    gen_xovalidated: ExtValue[int]
    "Crossovers validated"
    gen_xoinvalid: ExtValue[int]
    """
    Crossovers invalid
    
    couldn't be repaired
    """
    gen_xofailed: ExtValue[int]
    """
    Crossovers failed
    
    couldn't be performed
    """
    gen_mutimpr: ExtValue[float]
    """
    Mutations total effect
    
    total cumulative mutation change
    """
    gen_xoimpr: ExtValue[float]
    """
    Crossovers total effect
    
    total cumulative crossover change
    """

    @staticmethod
    def clrstats() -> ExtValue[None]:
        "Clear stats and history"
        ...

    @staticmethod
    def _propertyClear() -> ExtValue[None]:
        """
        Remove all properties

        Using most _property functions is restricted for internal purposes. Use "property:" or "state:" definitions in your script files to change object properties.
        """
        ...

    @staticmethod
    def _propertyAdd(id: str, type_description: str, name: str, flags: int, help_text: str) -> ExtValue[None]:
        """
        Add property (id,type,name,help)

        Using most _property functions is restricted for internal purposes. Use "property:" or "state:" definitions in your script files to change object properties.
        """
        ...

    @staticmethod
    def _propertyRemove(index: int) -> ExtValue[None]:
        """
        Remove property

        Using most _property functions is restricted for internal purposes. Use "property:" or "state:" definitions in your script files to change object properties.
        """
        ...

    @staticmethod
    def _propertyChange(id: str, type_description: str, name: str, flags: int, help_text: str) -> ExtValue[None]:
        """
        Change property

        Using most _property functions is restricted for internal purposes. Use "property:" or "state:" definitions in your script files to change object properties.
        """
        ...

    @staticmethod
    def _propertyAddGroup(name: str) -> ExtValue[None]:
        """
        Add property group

        Using most _property functions is restricted for internal purposes. Use "property:" or "state:" definitions in your script files to change object properties.
        """
        ...

    @staticmethod
    def _propertyRemoveGroup(index: int) -> ExtValue[None]:
        """
        Remove property group

        Using most _property functions is restricted for internal purposes. Use "property:" or "state:" definitions in your script files to change object properties.
        """
        ...

    @staticmethod
    def _propertyExists(name: str) -> ExtValue[int]:
        "Check for property existence"
        ...

    _property_changed_index: ExtValue[int]
    "Last changed property index"
    _property_changed_id: ExtValue[str]
    "Last changed property id"
    st_count: ExtValue[int]
    "Count"
    st_min_numparts: ExtValue[float]
    "Minimal Number of body Parts"
    st_avg_numparts: ExtValue[float]
    "Average Number of body Parts"
    st_max_numparts: ExtValue[float]
    "Maximal Number of body Parts"
    st_min_numjoints: ExtValue[float]
    "Minimal Number of body Joints"
    st_avg_numjoints: ExtValue[float]
    "Average Number of body Joints"
    st_max_numjoints: ExtValue[float]
    "Maximal Number of body Joints"
    st_min_numneurons: ExtValue[float]
    "Minimal Number of neurons"
    st_avg_numneurons: ExtValue[float]
    "Average Number of neurons"
    st_max_numneurons: ExtValue[float]
    "Maximal Number of neurons"
    st_min_numconnections: ExtValue[float]
    "Minimal Number of neural connections"
    st_avg_numconnections: ExtValue[float]
    "Average Number of neural connections"
    st_max_numconnections: ExtValue[float]
    "Maximal Number of neural connections"
    st_min_num: ExtValue[float]
    "Minimal Ordinal number"
    st_avg_num: ExtValue[float]
    "Average Ordinal number"
    st_max_num: ExtValue[float]
    "Maximal Ordinal number"
    st_min_gnum: ExtValue[float]
    "Minimal Generation"
    st_avg_gnum: ExtValue[float]
    "Average Generation"
    st_max_gnum: ExtValue[float]
    "Maximal Generation"
    st_min_instances: ExtValue[float]
    "Minimal Instances"
    st_avg_instances: ExtValue[float]
    "Average Instances"
    st_max_instances: ExtValue[float]
    "Maximal Instances"
    st_min_lifespan: ExtValue[float]
    "Minimal Life span"
    st_avg_lifespan: ExtValue[float]
    "Average Life span"
    st_max_lifespan: ExtValue[float]
    "Maximal Life span"
    st_min_velocity: ExtValue[float]
    "Minimal Velocity"
    st_avg_velocity: ExtValue[float]
    "Average Velocity"
    st_max_velocity: ExtValue[float]
    "Maximal Velocity"
    st_min_distance: ExtValue[float]
    "Minimal Distance"
    st_avg_distance: ExtValue[float]
    "Average Distance"
    st_max_distance: ExtValue[float]
    "Maximal Distance"
    st_min_vertvel: ExtValue[float]
    "Minimal Vertical velocity"
    st_avg_vertvel: ExtValue[float]
    "Average Vertical velocity"
    st_max_vertvel: ExtValue[float]
    "Maximal Vertical velocity"
    st_min_vertpos: ExtValue[float]
    "Minimal Vertical position"
    st_avg_vertpos: ExtValue[float]
    "Average Vertical position"
    st_max_vertpos: ExtValue[float]
    "Maximal Vertical position"
    st_min_fit: ExtValue[float]
    "Minimal Fitness"
    st_avg_fit: ExtValue[float]
    "Average Fitness"
    st_max_fit: ExtValue[float]
    "Maximal Fitness"
    st_min_fit2: ExtValue[float]
    "Minimal Final fitness"
    st_avg_fit2: ExtValue[float]
    "Average Final fitness"
    st_max_fit2: ExtValue[float]
    "Maximal Final fitness"
    st_min_c_velocity: ExtValue[float]
    "Minimal Recent period velocity"
    st_avg_c_velocity: ExtValue[float]
    "Average Recent period velocity"
    st_max_c_velocity: ExtValue[float]
    "Maximal Recent period velocity"
    st_min_c_vertvelocity: ExtValue[float]
    "Minimal Recent period vertical velocity"
    st_avg_c_vertvelocity: ExtValue[float]
    "Average Recent period vertical velocity"
    st_max_c_vertvelocity: ExtValue[float]
    "Maximal Recent period vertical velocity"
    st_min_c_vertpos: ExtValue[float]
    "Minimal Recent period vertical position"
    st_avg_c_vertpos: ExtValue[float]
    "Average Recent period vertical position"
    st_max_c_vertpos: ExtValue[float]
    "Maximal Recent period vertical position"
    st_min_pos_x: ExtValue[float]
    "Minimal Position x"
    st_avg_pos_x: ExtValue[float]
    "Average Position x"
    st_max_pos_x: ExtValue[float]
    "Maximal Position x"
    st_min_pos_y: ExtValue[float]
    "Minimal Position y"
    st_avg_pos_y: ExtValue[float]
    "Average Position y"
    st_max_pos_y: ExtValue[float]
    "Maximal Position y"
    st_min_pos_z: ExtValue[float]
    "Minimal Position z"
    st_avg_pos_z: ExtValue[float]
    "Average Position z"
    st_max_pos_z: ExtValue[float]
    "Maximal Position z"
    st_min_size_x: ExtValue[float]
    "Minimal Bounding box x size"
    st_avg_size_x: ExtValue[float]
    "Average Bounding box x size"
    st_max_size_x: ExtValue[float]
    "Maximal Bounding box x size"
    st_min_size_y: ExtValue[float]
    "Minimal Bounding box y size"
    st_avg_size_y: ExtValue[float]
    "Average Bounding box y size"
    st_max_size_y: ExtValue[float]
    "Maximal Bounding box y size"
    st_min_size_z: ExtValue[float]
    "Minimal Bounding box z size"
    st_avg_size_z: ExtValue[float]
    "Average Bounding box z size"
    st_max_size_z: ExtValue[float]
    "Maximal Bounding box z size"
    st_min_center_x: ExtValue[float]
    "Minimal center.x"
    st_avg_center_x: ExtValue[float]
    "Average center.x"
    st_max_center_x: ExtValue[float]
    "Maximal center.x"
    st_min_center_y: ExtValue[float]
    "Minimal center.y"
    st_avg_center_y: ExtValue[float]
    "Average center.y"
    st_max_center_y: ExtValue[float]
    "Maximal center.y"
    st_min_center_z: ExtValue[float]
    "Minimal center.z"
    st_avg_center_z: ExtValue[float]
    "Average center.z"
    st_max_center_z: ExtValue[float]
    "Maximal center.z"


class StopEvent(ExtValue):
    "Used in onSlaveStop() which is called when a Slave Simulator is stopped."

    index: ExtValue[int]
    "slave index"
    slave: ExtValue  # Simulator


class String(ExtValue):
    "String functions library."

    @staticmethod
    def len(_: str) -> ExtValue[int]:
        """
        String length

        String.len("abcdef") == 6
        """
        ...

    @staticmethod
    def replace(input_string: str, search: str, substitute: str) -> ExtValue[str]:
        'String.replace("abcdef","cd","X") == "abXef"'
        ...

    @staticmethod
    def split(text_to_split: str, word_separator: str) -> ExtValue:  # returns Vector
        """
        return the vector of substrings, cut at separator positions.
        subsequent separators give empty words:
        split("word1---word2-word3","-") returns ["word1","","","word2","word3"]
        """
        ...

    @staticmethod
    def split2(text_to_split: str, word_separator: str) -> ExtValue:  # returns Vector
        """
        Split, merging separators first

        return the vector of substrings, cut at separator positions.
        subsequent separators are treated as one:
        split2("word1---word2-word3","-") returns ["word1","word2","word3"]
        """
        ...

    @staticmethod
    def indexOf(_: str, substring: str) -> ExtValue[int]:
        """
        Search for substring

        String.indexOf("abcdef","cd") == 2
        String.indexOf("abcdef","dc") == -1
        """
        ...

    @staticmethod
    def indexOfStart(_: str, substring: str, start_index: int) -> ExtValue[int]:
        """
        Search for substring

        String.indexOfStart("abcdef","cd",1) == 2
        String.indexOfStart("abcdef","cd",3) == -1
        """
        ...

    @overload
    @staticmethod
    def substr(_: str, first_character: int, number_of_characters: int) -> ExtValue[str]:
        """
        Substring

        String.substr("abcdef",3,2) == "de"
        """
        ...

    @overload
    @staticmethod
    def substr(_: str, first_character: int) -> ExtValue[str]:
        """
        substring

        String.substr("abcdef",3) == "def"
        """
        ...

    @staticmethod
    def left(_: str, number_of_characters: int) -> ExtValue[str]:
        """
        Left substring

        String.left("abcdef",3) == "abc"
        """
        ...

    @staticmethod
    def right(_: str, number_of_characters: int) -> ExtValue[str]:
        """
        Right substring

        String.right("abcdef",3) == "def"
        """
        ...

    @staticmethod
    def trim(_: str) -> ExtValue[str]:
        "Removes whitespace from both sides of a string."
        ...

    @staticmethod
    def startsWith(string: str, substring: str) -> ExtValue[int]:
        "Test if starts with substring"
        ...

    @staticmethod
    def endsWith(string: str, substring: str) -> ExtValue[int]:
        "Test if ends with substring"
        ...

    @staticmethod
    def format(format_string: str, value_or_vector: Any) -> ExtValue[str]:
        """
        Formatted string conversion

        Works like the standard C library "sprintf()". The '%' operator can be used as a shortcut, e.g. String.format("%x",123) is equivalent of "%x" % 123
        Character seqences beginning with % found in the format string are replaced by formatted values produced according to their corresponding format specifiers: %[-][+][0][width[.precision]]type
         -: left adjust (default is right adjust)
         +: place a sign (+ or -) before a number
         0: the value should be zero padded
         width: minimum field width
         precision: minimum number of decimal digits
         type: d=decimal integer, x/X=hexadecimal integer, f/g=floating point number, e="scientific" style floating point, c=character of a given ascii code, t=time, %=special case, outputs the literal % character
        Multiple values can be formatted in one call, by passing a vector as the second argument:
        String.format("a=%03d b=%.2f c=%s",[a,b,c]) or "a=%03d b=%.2f c=%s" % [a,b,c]
        Alternatively, if no % characters are required in the output string, the chained call can be used:
        "a=%03d b=%.2f c=%s" % a % b % c
        The above expression works as expected, because, unlike the regular sprintf, the formatting function preserves % characters left after using all input arguments:
         input:          "a=%03d b=%.2f c=%s" % a % b % c
         actual meaning: (("a=%03d b=%.2f c=%s" % a) % b) % c
         phase 1:        ("a=000 b=%.2f c=%s" % b) % c
         phase 2:        "a=000 b=0.00 c=%s" % c
         result:         "a=000 b=0.00 c=0"

        Examples:
         String.format("|%07.2f|",Math.pi) == "|0003.14|"
         String.format("|%04x|",255) == "|00ff|"
         String.format("|%7s|","text") == "|   text|"
         String.format("|%-7d|",12345) == "|12345  |"
         String.format("%t",Math.time) == "Sun Apr 29 19:22:02 2007"
         String.format("%T",Math.time) == "2007-05-29 19:22:02"
         String.format("x=%d%%",100) == "100%"
        """
        ...

    @staticmethod
    def parseInt(_: str) -> ExtValue[int]:
        """
        Parse integer

        If the supplied string is not an integer, returns 0 and posts an error message.
        """
        ...

    @staticmethod
    def parseFloat(_: str) -> ExtValue[float]:
        """
        Parse floating point

        If the supplied string is not a number, returns 0.0 and posts an error message.
        """
        ...

    @staticmethod
    def parseNumber(_: str) -> ExtValue:  # returns untyped
        """
        Parse integer or floating point

        Returns an integer, a floating point, or null if the string cannot be parsed as a number.
        The 'typeof' operator can be used to distinguish between an integer and a floating point value:
        typeof(String.parseNumber("qwerty")) == "null"
        typeof(String.parseNumber("1234")) == "int"
        typeof(String.parseNumber("3.14")) == "float"
        """
        ...

    @staticmethod
    def code(_: str) -> ExtValue[int]:
        "ASCII code of the character"
        ...

    @staticmethod
    def char(_: int) -> ExtValue[str]:
        "Character from ASCII"
        ...

    @staticmethod
    def toUpper(_: str) -> ExtValue[str]:
        "Make uppercase version"
        ...

    @staticmethod
    def toLower(_: str) -> ExtValue[str]:
        "Make lowercase version"
        ...

    @staticmethod
    def serialize(_: Any) -> ExtValue[str]:
        "Converts to textual representation, preserving object hierarchy."
        ...

    @staticmethod
    def deserialize(_: str) -> ExtValue:  # returns untyped
        """
        Extracts objects from textual representation. Error object is returned if deserialization fails.
        Example:
        var ret=String.deserialize(something);
        if (typeof(ret)=="Error") Simulator.print("something is wrong: "+ret.message);
        """
        ...

    @staticmethod
    def toJSON(_: Any) -> ExtValue[str]:
        """
        JSON serialization

        Exports to JSON format, preserving object hierarchy (excluding recursion).
        """
        ...

    @staticmethod
    def hash(_: str) -> ExtValue[int]:
        "Compute 32-bit hash"
        ...

    @staticmethod
    def diff(_: str, __2: str) -> ExtValue:  # returns Vector
        """
        Calculate string difference

        Returns the vector of minimal differences between two strings. The vector contains either 2-element subvectors with differing substrings ["text-1","text-2"] or strings "same".

        For example, String.diff("thisisatest", "testing123testing") returns [t,[hi,e],s,[,t],i,[sa,ng123],test,[,ing]].

        Use this function for short strings, as it requires 4*length(string1)*length(string2) bytes of memory.
        """
        ...

    @staticmethod
    def urlEncode(_: str) -> ExtValue[str]:
        "URL encode"
        ...

    @staticmethod
    def urlDecode(_: str) -> ExtValue[str]:
        "URL decode"
        ...

    @staticmethod
    def quoteEof(_: str) -> ExtValue[str]:
        """
        quote eof

        Add leading backslash to lines containing just 'eof' (or previously quoted 'eof') (for use in the network protocol implementation)
        """
        ...

    @staticmethod
    def unquoteEof(_: str) -> ExtValue[str]:
        """
        unquote eof

        Remove one level of backslash quoting from lines containing quoted 'eof' (for use in the network protocol implementation)
        """
        ...

    SERIALIZATION_PREFIX: ExtValue[str]
    """
    Serialization prefix
    
    String prefix used in the Framsticks file format to indicate object fields that contain serialized objects.
    """
    ESC: ExtValue[str]
    "Escape character"
    NBSP: ExtValue[str]
    "Non-breaking space character"


class UserScripts(ExtValue):
    @staticmethod
    def _propertyClear() -> ExtValue[None]:
        """
        Remove all properties

        Using most _property functions is restricted for internal purposes. Use "property:" or "state:" definitions in your script files to change object properties.
        """
        ...

    @staticmethod
    def _propertyAdd(id: str, type_description: str, name: str, flags: int, help_text: str) -> ExtValue[None]:
        """
        Add property (id,type,name,help)

        Using most _property functions is restricted for internal purposes. Use "property:" or "state:" definitions in your script files to change object properties.
        """
        ...

    @staticmethod
    def _propertyRemove(index: int) -> ExtValue[None]:
        """
        Remove property

        Using most _property functions is restricted for internal purposes. Use "property:" or "state:" definitions in your script files to change object properties.
        """
        ...

    @staticmethod
    def _propertyChange(id: str, type_description: str, name: str, flags: int, help_text: str) -> ExtValue[None]:
        """
        Change property

        Using most _property functions is restricted for internal purposes. Use "property:" or "state:" definitions in your script files to change object properties.
        """
        ...

    @staticmethod
    def _propertyAddGroup(name: str) -> ExtValue[None]:
        """
        Add property group

        Using most _property functions is restricted for internal purposes. Use "property:" or "state:" definitions in your script files to change object properties.
        """
        ...

    @staticmethod
    def _propertyRemoveGroup(index: int) -> ExtValue[None]:
        """
        Remove property group

        Using most _property functions is restricted for internal purposes. Use "property:" or "state:" definitions in your script files to change object properties.
        """
        ...

    @staticmethod
    def _propertyExists(name: str) -> ExtValue[int]:
        "Check for property existence"
        ...

    _property_changed_index: ExtValue[int]
    "Last changed property index"
    _property_changed_id: ExtValue[str]
    "Last changed property id"


class Vector(ExtValue):
    """
    Vector is a 1-dimensional array indexed by an integer value (starting from 0). Multidimensional arrays can be simulated by putting other Vector objects into a Vector.
    Examples:
        var v1=Vector.new();
        v1.add(123);
        v1.add("string");
    A short way of doing the same (square brackets create a vector):
        var v2=[123,"string"];
    Simulate a 2D array:
        var v3=[[1,2,3],[4,5],[6]];
    You can iterate directly over values of a Vector using for(...in...) loops:
        for(var element in v3) Simulator.print(element);
    """

    @staticmethod
    def clear() -> ExtValue[None]:
        "Clear data"
        ...

    size: ExtValue[int]
    "Element count"

    @staticmethod
    def remove(position: int) -> ExtValue[None]:
        "Remove at position"
        ...

    @staticmethod
    def get(position: int) -> ExtValue:  # returns untyped
        """
        Get value at position

        object[position] can be always used instead of object.get(position)
        """
        ...

    @staticmethod
    def set(position: int, value: Any) -> ExtValue[None]:
        """
        Set value at position

        object[position]=value can be always used instead of object.set(position,value)
        """
        ...

    @staticmethod
    def insert(position: int, value: Any) -> ExtValue[None]:
        "Insert value at position"
        ...

    @staticmethod
    def add(value: Any) -> ExtValue[None]:
        "Append at the end"
        ...

    @staticmethod
    def find(value: Any) -> ExtValue[int]:
        "returns the element index or -1 if not found"
        ...

    avg: ExtValue  # untyped
    "Average"
    stdev: ExtValue  # untyped
    """
    Standard deviation
    
    =sqrt(sum((element[i]-avg)^2)/(size-1)) which is estimated population std.dev. from sample std.dev.
    """
    toString: ExtValue[str]
    "Textual form"

    @staticmethod
    def new() -> ExtValue:  # returns Vector
        "Create new Vector"
        ...

    @staticmethod
    def sort(comparator: "FunctionReference") -> ExtValue[None]:
        """
        Sort elements (in place)

        comparator can be null, giving the "natural" sorting order (depending on element type), otherwise it must be a function reference obtained from the 'function' operator.

        Example:
        function compareLastDigit(a,b) {return (a%10)<(b%10);}
        var v=[16,23,35,42,54,61];
        v.sort(function compareLastDigit);
        """
        ...

    iterator: ExtValue  # Object

    @staticmethod
    def clone() -> ExtValue:  # returns Vector
        """
        Create a clone

        The resulting clone is a shallow copy (contains the same object references as the original). A deep copy can be obtained through serialization: String.deserialize(String.serialize(object));
        """
        ...


class WireframeAppearance(ExtValue):
    "This object defines appearance of the elements of creatures (applies to the 'wireframe' display mode). Default shape definitions make food's \"p:\" look like a sphere, and manipulator's \"p:\" look like a robot hand. The model's Vstyle property is the name of the shape. Developers of experiment definitions can introduce new Vstyle(s) for their expdef and provide appropriate shape definitions by calling WireframeAppearance.set(...) in the onExpDefLoad() function."

    @staticmethod
    def set(id: str, definition: str, color: int) -> ExtValue[None]:
        r"""
        Id

        Arguments:

        - "id" - can be
          "1p_STYLENAME": affects a single-Part creature (without Joints)
          "p_STYLENAME": affects all normal Parts
          "j_STYLENAME": affects Joints
             (STYLENAME corresponds to the Model.Vstyle value, and it can be empty).

        - "definition" is a genotype describing the object shape

        - "color" can be 0xRRGGBB or one of the special values: -3 = default creature color, -4 = default food color, -5 = default manipulator color

        Examples:
        WireframeAppearance.set("j_predator","X",0xff0000);//make all predators (i.e. creatures with Vstyle=predator) red
        WireframeAppearance.set("1p_food","...some...genotype...",-4);//change food appearance
        WireframeAppearance.set("p_","//0\np:0,0,0\np:-0.1,0,0\np:0.1,0,0\np:0,-0.1,0\np:0,0.1,0\np:0,0,-0.1\np:0,0,0.1\nj:0,1\nj:0,2\nj:0,3\nj:0,4\nj:0,5\nj:0,6\n",0);//make Parts' orientation axes visible
        """
        ...

    @staticmethod
    def clear() -> ExtValue[None]: ...


class World(ExtValue):
    "Environment properties."

    wrldtyp: ExtValue[int]
    "Type"
    wrldsiz: ExtValue[float]
    """
    Size
    
    Side length of the world
    """
    wrldmap: ExtValue[str]
    """
    Map
    
    Description of the world (only applies to world types: "Blocks" or "Heightfield").
    To generate a random landscape, use:
       r[scaling] <sizex> <sizey> [seed]
    To generate a custom landscape, provide height values:
       m[scaling] <sizex> <sizey> digits...
     or
       M[scaling] <sizex> <sizey> numbers...
    
    "digits..." is a sequence of integer values 0,1,2,..,9. You may also use '-' and '|' characters for smooth slides between blocks.
    "numbers..." is a sequence of floating point values, so the "M" option provides more freedom.
    [scaling] is an optional linear scaling expression in the form of *FACTOR+OFFSET or *FACTOR-OFFSET, for example "r*0.1-2 5 5" creates a 5x5 random map with a 10% amplitude, shifted down by 2.
    
    See also the WorldMap object.
    """
    wrldwat: ExtValue[float]
    "Water level"
    wrldbnd: ExtValue[int]
    """
    Boundaries
    
    Teleporting a creature that is outside of the world area is attempted every 'performance sampling period' steps. Teleport succeeds only when the target location in the world is empty (there is no collision).
    """
    wrldg: ExtValue[float]
    """
    Gravity
    
    You can adjust gravity for your experiments.
    The "official" setting used to evaluate and compare creatures is 1.
    """

    @staticmethod
    def wrldchg() -> ExtValue[None]:
        "Trigger world update"
        ...

    simtype: ExtValue[int]
    """
    Simulation engine
    
    MechaStick is a fast and simple primary Framsticks simulation engine.
    ODE is Open Dynamics Engine by Russel Smith et al.
    
    NOTE: switching between simulation engines causes removal of all objects in the world (e.g. creatures).
    """
    nnspeed: ExtValue[float]
    """
    NN speed
    
    Number of neural network simulation steps in each physics simulation step
    """
    rndcollisions: ExtValue[int]
    """
    Random collision order
    
    When enabled, custom collision handlers are invoked in random order. This can help remove unfair bias in some experiments - for example where the same collision order in each simulation step would cause some creatures colliding with food to consume energy while other colliding creatures would starve.
    """
    signals: ExtValue  # WorldSignals
    "Signal sources"


class WorldMap(ExtValue):
    'Environment details for "Blocks" and "Heightfield" world type. The most important concept is a "Map", which is the array of Map elements.'

    xsize: ExtValue[int]
    "Map x size"
    ysize: ExtValue[int]
    "Map y size"

    @staticmethod
    def getAsString(alternate_script: str, special_arguments: Any) -> ExtValue[str]:
        """
        String representation of the world surface

        This function returns the universal polygonal description of the world surface (regardless of the world type). The data is provided in the following simple textual format with each line describing one vertex (3 floating point values) or one face (3 or 4 vertex indices - faces can be triangles or quads), which is a subset of the Wavefront .obj file format:

        v first vertex coordinates
        v second vertex coordinates
        v ...etc
        f first face indices
        f second face indices
        f ...etc

        For example, the default flat world consists of 4 vertices and 1 quad face:

        v 0 0 0
        v 20.0 0 0
        v 20.0 20.0 0
        v 0 20.0 0
        f 1 2 3 4

        Internaly, the data returned by this function is generated by the 'scripts/worldmap-faces.script' file, so you can refer to its source if needed.
        The first argument to getAsString() (if not null or empty string) selects an alternate userscript to be used instead of the default 'worldmap-faces.script', allowing for extension and customization.
        Examples:
        WorldMap.getAsString(null,null) //use the default script
        WorldMap.getAsString("myscript","myarg") //calls "WorldMap_myscript", passing "myarg" to its main_args() function.
        """
        ...

    @staticmethod
    def getHeight(x: float, y: float) -> ExtValue[float]:
        """
        Height

        Height at any 2d coordinate
        """
        ...

    @staticmethod
    def getMap(x: int, y: int) -> ExtValue:  # returns Object
        """
        get map element object

        Retrieve the map element object for a given grid coordinates (x,y), where 0<=x<xsize, 0<=y<ysize.

        The obtained value type depends on the current world type.
        - Blocks world objects provide 'z' and 'type' values (z is the block height, type is 0=flat block, 1=west-east slope, 2=north-south slope).
        - Heightfield world objects provide just the 'z' value (which is the grid point height).

        See the 'scripts/worldmap_faces.script' file for a practical example on how to obtain the world geometry data using WorldMap.getMap().

        Quirks: Internally, maps have more elements than could be deduced from the user-supplied World.wrldmap, as additional rows of elements are added to provide smooth transitions to flat surroundings, which is reflected in 'xsize' and 'ysize'.
        WorldMap.getMap() arguments refer to this internal representation, so the object corresponding to the first map element is not (0,0), but (1,1) for Heightfield or (2,2) for Blocks world. Not starting from (0,0) can be convenient - for example, given any valid grid coordinates (x,y), all its neighbors are also valid and can be requested through getMap() without introducing any special cases in the code.
        """
        ...

    @overload
    @staticmethod
    def intersect(a_3d_point: "Vector", a_3d_direction: "Vector", range: float) -> ExtValue:  # returns Vector
        """
        Calculate the intersection point between the world surface and the ray projected from "3d point" towards the given direction. 3D points are actually 3-elements Vector objects. The resulting vector contains the additional fourth element - the intersection point distance. The function returns null if there is no intersection.

        See "standard_events.inc" file, which uses "intersect" for calculating the world coordinates corresponding to the user-clicked screen location.
        Bugs: This function does not currently handle the heightfield environment correctly (works as if it was flat)
        """
        ...

    @overload
    @staticmethod
    def intersect(a_3d_point: "Vector", a_3d_direction: "Vector") -> ExtValue:  # returns Vector
        "Works like intersect(3d point,3d direction,range) for inifinite range, that is without limiting the intersection distance"
        ...


class WorldSignals(ExtValue):
    """
    Use this object to create stationary signals (not associated with any moving object) and to receive signals from any location in the world. There are Creature-based and Neuro-based variants of this object that automatically operate from creature's or neuron's position.

    See also: Signal, CreatureSignals, NeuroSignals.
    """

    @staticmethod
    def add(position: "XYZ", channel: str) -> ExtValue:  # returns Signal
        "Create a new signal"
        ...

    @staticmethod
    def receive(position: "XYZ", channel: str) -> ExtValue[float]:
        """
        Receive signal in channel

        Receive the aggregated signal power in a given channel.
        """
        ...

    @staticmethod
    def receiveSet(position: "XYZ", channel: str, max_distance: float) -> ExtValue:  # returns Vector
        """
        Receive signals in range

        Get all signals in the specified range. Returns a read-only vector object containing Signal objects - individual signals can be accessed as result[0], .., result[result.size-1].
        """
        ...

    @staticmethod
    def receiveFilter(position: "XYZ", channel: str, max_distance: float, flavor: float, flavorfilter: float) -> ExtValue[float]:
        """
        Receive filtered signal

        Receive the aggregated signal power in a given channel.

        Additional filtering options:
        - Max distance only receives the neighbor signals (based on their physical location)
        - Flavor filtering: only signals having the flavor similar to the specified value will be received. The flavorfilter value is the difference of flavor that reduces the received signal to 0. The "flavor attenuation" is linear, i.e., signals differing by (filter/2) in flavor will be reduced to 50%.
        """
        ...

    @staticmethod
    def receiveSingle(position: "XYZ", channel: str, max_distance: float) -> ExtValue:  # returns Signal
        """
        Receive strongest

        Find the signal source that has the highest signal power (taking into account distance).
        """
        ...

    @staticmethod
    def get(index: int) -> ExtValue:  # returns Signal
        "Access individual signals (index = 0 .. size-1)"
        ...

    size: ExtValue[int]
    "Number of signals in this set"

    @staticmethod
    def clear() -> ExtValue[None]:
        "Delete all signals"
        ...


class XYZ(ExtValue):
    "3D vector"

    x: ExtValue[float]
    y: ExtValue[float]
    z: ExtValue[float]

    @staticmethod
    def new(x: float, y: float, z: float) -> ExtValue:  # returns XYZ
        """
        create new XYZ object

        3D vectors objects can be also created using the (x,y,z) notation, i.e. var v=(1,2,3) is the same as var v=XYZ.new(1,2,3);
        """
        ...

    @staticmethod
    def newFromVector(_: "Vector") -> ExtValue:  # returns XYZ
        """
        create new XYZ object

        used for deserialization
        """
        ...

    @staticmethod
    def clone() -> ExtValue:  # returns XYZ
        """
        create new XYZ object copying the coordinates

        Note: copying object references does not create new objects. Use clone() if a new object is needed.

        Example:
        var o1=(1,2,3), o2=o1, o3=o1.clone();
        o1.y=9999;
        //o2 is now (1,9999,3) but o3 is still (1,2,3)
        """
        ...

    @staticmethod
    def set(_: "XYZ") -> ExtValue[None]:
        "set (copy) coordinates from another XYZ object"
        ...

    @staticmethod
    def set3(x: float, y: float, z: float) -> ExtValue[None]:
        "set individual 3 coordinates"
        ...

    @staticmethod
    def add(_: "XYZ") -> ExtValue[None]:
        "Note: it does not return a new object, just modifies the existing one"
        ...

    @staticmethod
    def sub(_: "XYZ") -> ExtValue[None]:
        """
        subtract

        Note: it does not return a new object, just modifies the existing one
        """
        ...

    @staticmethod
    def scale(_: float) -> ExtValue[None]:
        "multiply by scalar"
        ...

    length: ExtValue[float]

    @staticmethod
    def normalize() -> ExtValue[None]:
        "scales the vector length to 1.0"
        ...

    toString: ExtValue[str]
    "textual form"
    toVector: ExtValue  # Vector
    "vector of [x,y,z]"

    @staticmethod
    def rotate(_: "Orient") -> ExtValue[None]:
        "rotate using Orient object"
        ...

    @staticmethod
    def revRotate(_: "Orient") -> ExtValue[None]:
        "reverse rotate using Orient object"
        ...

    @staticmethod
    def get(index: int) -> ExtValue[float]:
        """
        get one of coordinates

        this function makes the XYZ objects "indexable" (so you can use [] for accessing subsequent fields, like in Vector)
        """
        ...

